.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PARALLEL 1"
.TH PARALLEL 1 "2015-02-22" "20150222" "parallel"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
parallel \- build and execute shell command lines from standard input in parallel
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] < list_of_arguments
.PP
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] ( \fB:::\fR arguments |
\&\fB::::\fR argfile(s) ) ...
.PP
\&\fBparallel\fR \-\-semaphore [options] \fIcommand\fR
.PP
\&\fB#!/usr/bin/parallel\fR \-\-shebang [options] [\fIcommand\fR [arguments]]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1GNU \s0\fBparallel\fR is a shell tool for executing jobs in parallel using
one or more computers. A job can be a single command or a small
script that has to be run for each of the lines in the input. The
typical input is a list of files, a list of hosts, a list of users, a
list of URLs, or a list of tables. A job can also be a command that
reads from a pipe. \s-1GNU \s0\fBparallel\fR can then split the input into
blocks and pipe a block into each command in parallel.
.PP
If you use xargs and tee today you will find \s-1GNU \s0\fBparallel\fR very easy to
use as \s-1GNU \s0\fBparallel\fR is written to have the same options as xargs. If
you write loops in shell, you will find \s-1GNU \s0\fBparallel\fR may be able to
replace most of the loops and make them run faster by running several
jobs in parallel.
.PP
\&\s-1GNU \s0\fBparallel\fR makes sure output from the commands is the same output as
you would get had you run the commands sequentially. This makes it
possible to use output from \s-1GNU \s0\fBparallel\fR as input for other programs.
.PP
For each line of input \s-1GNU \s0\fBparallel\fR will execute \fIcommand\fR with
the line as arguments. If no \fIcommand\fR is given, the line of input is
executed. Several lines will be run in parallel. \s-1GNU \s0\fBparallel\fR can
often be used as a substitute for \fBxargs\fR or \fBcat | bash\fR.
.SS "Reader's guide"
.IX Subsection "Reader's guide"
Start by watching the intro videos for a quick introduction:
http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1
.PP
Then look at the \fB\s-1EXAMPLE\s0\fRs after the list of \fB\s-1OPTIONS\s0\fR. That will
give you an idea of what \s-1GNU \s0\fBparallel\fR is capable of.
.PP
Then spend an hour walking through the tutorial (\fBman
parallel_tutorial\fR). Your command line will love you for it.
.PP
Finally you may want to look at the rest of this manual if you have
special needs not already covered.
.PP
If you want to know the design decisions behind \s-1GNU \s0\fBparallel\fR, try:
\&\fBman parallel_design\fR. This is also a good intro if you intend to
change \s-1GNU \s0\fBparallel\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fIcommand\fR" 9
.IX Item "command"
Command to execute.  If \fIcommand\fR or the following arguments contain
replacement strings (such as \fB{}\fR) every instance will be substituted
with the input.
.Sp
If \fIcommand\fR is given, \s-1GNU \s0\fBparallel\fR solve the same tasks as
\&\fBxargs\fR. If \fIcommand\fR is not given \s-1GNU \s0\fBparallel\fR will behave
similar to \fBcat | sh\fR.
.Sp
The \fIcommand\fR must be an executable, a script, a composed command, or
a function.
.Sp
If it is a Bash function you need to \fBexport \-f\fR the function
first. To use aliases copy the full environment as described under
\&\fB\-\-env\fR and use \fBenv_parallel\fR instead of \fBparallel\fR.
.Sp
The command cannot contain the character \e257 (macron: X).
.IP "\fB{}\fR (beta testing)" 9
.IX Item "{} (beta testing)"
Input line. This replacement string will be replaced by a full line
read from the input source. The input source is normally stdin
(standard input), but can also be given with \fB\-a\fR, \fB:::\fR, or
\&\fB::::\fR.
.Sp
The replacement string \fB{}\fR can be changed with \fB\-I\fR.
.Sp
If the command line contains no replacement strings then \fB{}\fR will be
appended to the command line.
.IP "\fB{.}\fR (beta testing)" 9
.IX Item "{.} (beta testing)"
Input line without extension. This replacement string will be replaced
by the input with the extension removed. If the input line contains
\&\fB.\fR after the last \fB/\fR the last \fB.\fR till the end of the string will
be removed and \fB{.}\fR will be replaced with the
remaining. E.g. \fIfoo.jpg\fR becomes \fIfoo\fR, \fIsubdir/foo.jpg\fR becomes
\&\fIsubdir/foo\fR, \fIsub.dir/foo.jpg\fR becomes \fIsub.dir/foo\fR,
\&\fIsub.dir/bar\fR remains \fIsub.dir/bar\fR. If the input line does not
contain \fB.\fR it will remain unchanged.
.Sp
The replacement string \fB{.}\fR can be changed with \fB\-\-er\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{/}\fR (beta testing)" 9
.IX Item "{/} (beta testing)"
Basename of input line. This replacement string will be replaced by
the input with the directory part removed.
.Sp
The replacement string \fB{/}\fR can be changed with
\&\fB\-\-basenamereplace\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{//}\fR (beta testing)" 9
.IX Item "{//} (beta testing)"
Dirname of input line. This replacement string will be replaced by the
dir of the input line. See \fBdirname\fR(1).
.Sp
The replacement string \fB{//}\fR can be changed with
\&\fB\-\-dirnamereplace\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{/.}\fR (beta testing)" 9
.IX Item "{/.} (beta testing)"
Basename of input line without extension. This replacement string will
be replaced by the input with the directory and extension part
removed. It is a combination of \fB{/}\fR and \fB{.}\fR.
.Sp
The replacement string \fB{/.}\fR can be changed with
\&\fB\-\-basenameextensionreplace\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{#}\fR (beta testing)" 9
.IX Item "{#} (beta testing)"
Sequence number of the job to run. This replacement string will be
replaced by the sequence number of the job being run. It contains the
same number as \f(CW$PARALLEL_SEQ\fR.
.Sp
The replacement string \fB{#}\fR can be changed with \fB\-\-seqreplace\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{%}\fR (beta testing)" 9
.IX Item "{%} (beta testing)"
Job slot number. This replacement string will be replaced by the job's
slot number between 1 and number of jobs to run in parallel. There
will never be 2 jobs running at the same time with the same job slot
number.
.Sp
The replacement string \fB{%}\fR can be changed with \fB\-\-slotreplace\fR.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{\fR\fIn\fR\fB}\fR (beta testing)" 9
.IX Item "{n} (beta testing)"
Argument from input source \fIn\fR or the \fIn\fR'th argument. This
positional replacement string will be replaced by the input from input
source \fIn\fR (when used with \fB\-a\fR or \fB::::\fR) or with the \fIn\fR'th
argument (when used with \fB\-N\fR). If \fIn\fR is negative it refers to the
\&\fIn\fR'th last argument.
.Sp
To understand replacement strings see \fB{}\fR.
.IP "\fB{\fR\fIn\fR.\fB}\fR (beta testing)" 9
.IX Item "{n.} (beta testing)"
Argument from input source \fIn\fR or the \fIn\fR'th argument without
extension. It is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{.}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-a\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
extension removed.
.Sp
To understand positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR/\fB}\fR (beta testing)" 9
.IX Item "{n/} (beta testing)"
Basename of argument from input source \fIn\fR or the \fIn\fR'th argument.
It is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{/}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-a\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
directory (if any) removed.
.Sp
To understand positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR//\fB}\fR (beta testing)" 9
.IX Item "{n//} (beta testing)"
Dirname of argument from input source \fIn\fR or the \fIn\fR'th argument.
It is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{//}\fR.
.Sp
This positional replacement string will be replaced by the dir of the
input from input source \fIn\fR (when used with \fB\-a\fR or \fB::::\fR) or with
the \fIn\fR'th argument (when used with \fB\-N\fR). See \fBdirname\fR(1).
.Sp
To understand positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR/.\fB}\fR (beta testing)" 9
.IX Item "{n/.} (beta testing)"
Basename of argument from input source \fIn\fR or the \fIn\fR'th argument
without extension.  It is a combination of \fB{\fR\fIn\fR\fB}\fR, \fB{/}\fR, and
\&\fB{.}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-a\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
directory (if any) and extension removed.
.Sp
To understand positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{=\fR\fIperl expression\fR\fB=}\fR (beta testing)" 9
.IX Item "{=perl expression=} (beta testing)"
Replace with calculated \fIperl expression\fR. \fB\f(CB$_\fB\fR will contain the
same as \fB{}\fR. After evaluating \fIperl expression\fR \fB\f(CB$_\fB\fR will be used
as the value. It is recommended to only change \f(CW$_\fR but you have full
access to all of \s-1GNU \s0\fBparallel\fR's internal functions and data
structures.
.Sp
The \fB{=\fR\fIperl expression\fR\fB=}\fR must be given as a single string.
.Sp
See also: \fB\-\-rpl\fR \fB\-\-parens\fR
.IP "\fB{=\fR\fIn\fR \fIperl expression\fR\fB=}\fR (beta testing)" 9
.IX Item "{=n perl expression=} (beta testing)"
Positional equivalent to \fB{= perl expression =}\fR. To understand
positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.Sp
See also: \fB{= perl expression =}\fR \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB:::\fR \fIarguments\fR" 9
.IX Item "::: arguments"
Use arguments from the command line as input source instead of stdin
(standard input). Unlike other options for \s-1GNU \s0\fBparallel\fR \fB:::\fR is
placed after the \fIcommand\fR and before the arguments.
.Sp
The following are equivalent:
.Sp
.Vb 6
\&  (echo file1; echo file2) | parallel gzip
\&  parallel gzip ::: file1 file2
\&  parallel gzip {} ::: file1 file2
\&  parallel \-\-arg\-sep ,, gzip {} ,, file1 file2
\&  parallel \-\-arg\-sep ,, gzip ,, file1 file2
\&  parallel ::: "gzip file1" "gzip file2"
.Ve
.Sp
To avoid treating \fB:::\fR as special use \fB\-\-arg\-sep\fR to set the
argument separator to something else. See also \fB\-\-arg\-sep\fR.
.Sp
stdin (standard input) will be passed to the first process run.
.Sp
If multiple \fB:::\fR are given, each group will be treated as an input
source, and all combinations of input sources will be
generated. E.g. ::: 1 2 ::: a b c will result in the combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful for replacing
nested for-loops.
.Sp
\&\fB:::\fR and \fB::::\fR can be mixed. So these are equivalent:
.Sp
.Vb 11
\&  parallel echo {1} {2} {3} ::: 6 7 ::: 4 5 ::: 1 2 3
\&  parallel echo {1} {2} {3} :::: <(seq 6 7) <(seq 4 5) \e
\&    :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) echo {1} {2} {3} :::: <(seq 4 5) \e
\&    :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) \-a <(seq 4 5) echo {1} {2} {3} \e
\&    ::: 1 2 3
\&  seq 6 7 | parallel \-a \- \-a <(seq 4 5) echo {1} {2} {3} \e
\&    ::: 1 2 3
\&  seq 4 5 | parallel echo {1} {2} {3} :::: <(seq 6 7) \- \e
\&    ::: 1 2 3
.Ve
.IP "\fB::::\fR \fIargfiles\fR" 9
.IX Item ":::: argfiles"
Another way to write \fB\-a\fR \fIargfile1\fR \fB\-a\fR \fIargfile2\fR ...
.Sp
\&\fB:::\fR and \fB::::\fR can be mixed.
.Sp
See \fB\-a\fR, \fB:::\fR and \fB\-\-xapply\fR.
.IP "\fB\-\-null\fR" 9
.IX Item "--null"
.PD 0
.IP "\fB\-0\fR" 9
.IX Item "-0"
.PD
Use \s-1NUL\s0 as delimiter.  Normally input lines will end in \en
(newline). If they end in \e0 (\s-1NUL\s0), then use this option. It is useful
for processing arguments that may contain \en (newline).
.IP "\fB\-\-arg\-file\fR \fIinput-file\fR" 9
.IX Item "--arg-file input-file"
.PD 0
.IP "\fB\-a\fR \fIinput-file\fR" 9
.IX Item "-a input-file"
.PD
Use \fIinput-file\fR as input source. If you use this option, stdin
(standard input) is given to the first process run.  Otherwise, stdin
(standard input) is redirected from /dev/null.
.Sp
If multiple \fB\-a\fR are given, each \fIinput-file\fR will be treated as an
input source, and all combinations of input sources will be
generated. E.g. The file \fBfoo\fR contains \fB1 2\fR, the file \fBbar\fR
contains \fBa b c\fR.  \fB\-a foo\fR \fB\-a bar\fR will result in the combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful for replacing
nested for-loops.
.Sp
See also \fB\-\-xapply\fR and \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB\-\-arg\-file\-sep\fR \fIsep-str\fR" 9
.IX Item "--arg-file-sep sep-str"
Use \fIsep-str\fR instead of \fB::::\fR as separator string between command
and argument files. Useful if \fB::::\fR is used for something else by the
command.
.Sp
See also: \fB::::\fR.
.IP "\fB\-\-arg\-sep\fR \fIsep-str\fR" 9
.IX Item "--arg-sep sep-str"
Use \fIsep-str\fR instead of \fB:::\fR as separator string. Useful if \fB:::\fR
is used for something else by the command.
.Sp
Also useful if you command uses \fB:::\fR but you still want to read
arguments from stdin (standard input): Simply change \fB\-\-arg\-sep\fR to a
string that is not in the command line.
.Sp
See also: \fB:::\fR.
.IP "\fB\-\-bar\fR" 9
.IX Item "--bar"
Show progress as a progress bar. In the bar is shown: % of jobs
completed, estimated seconds left, and number of jobs started.
.Sp
It is compatible with \fBzenity\fR:
.Sp
.Vb 2
\&  seq 1000 | parallel \-j30 \-\-bar \*(Aq(echo {};sleep 0.1)\*(Aq \e
\&    2> >(zenity \-\-progress \-\-auto\-kill) | wc
.Ve
.IP "\fB\-\-basefile\fR \fIfile\fR" 9
.IX Item "--basefile file"
.PD 0
.IP "\fB\-\-bf\fR \fIfile\fR" 9
.IX Item "--bf file"
.PD
\&\fIfile\fR will be transferred to each sshlogin before a jobs is
started. It will be removed if \fB\-\-cleanup\fR is active. The file may be
a script to run or some common base data needed for the jobs.
Multiple \fB\-\-bf\fR can be specified to transfer more basefiles. The
\&\fIfile\fR will be transferred the same way as \fB\-\-transfer\fR.
.IP "\fB\-\-basenamereplace\fR \fIreplace-str\fR" 9
.IX Item "--basenamereplace replace-str"
.PD 0
.IP "\fB\-\-bnr\fR \fIreplace-str\fR" 9
.IX Item "--bnr replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{/}\fR for
basename of input line.
.IP "\fB\-\-basenameextensionreplace\fR \fIreplace-str\fR" 9
.IX Item "--basenameextensionreplace replace-str"
.PD 0
.IP "\fB\-\-bner\fR \fIreplace-str\fR" 9
.IX Item "--bner replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{/.}\fR for basename of input line without extension.
.IP "\fB\-\-bg\fR" 9
.IX Item "--bg"
Run command in background thus \s-1GNU \s0\fBparallel\fR will not wait for
completion of the command before exiting. This is the default if
\&\fB\-\-semaphore\fR is set.
.Sp
See also: \fB\-\-fg\fR, \fBman sem\fR.
.Sp
Implies \fB\-\-semaphore\fR.
.IP "\fB\-\-bibtex\fR" 9
.IX Item "--bibtex"
Print the BibTeX entry for \s-1GNU \s0\fBparallel\fR and disable citation
notice.
.IP "\fB\-\-block\fR \fIsize\fR" 9
.IX Item "--block size"
.PD 0
.IP "\fB\-\-block\-size\fR \fIsize\fR" 9
.IX Item "--block-size size"
.PD
Size of block in bytes. The \fIsize\fR can be postfixed with K, M, G, T, P,
k, m, g, t, or p which would multiply the size with 1024, 1048576,
1073741824, 1099511627776, 1125899906842624, 1000, 1000000,
1000000000, 1000000000000, or 1000000000000000 respectively.
.Sp
\&\s-1GNU \s0\fBparallel\fR tries to meet the block size but can be off by the
length of one record. For performance reasons \fIsize\fR should be bigger
than a single record.
.Sp
\&\fIsize\fR defaults to 1M.
.Sp
See \fB\-\-pipe\fR and \fB\-\-pipepart\fR for use of this.
.IP "\fB\-\-cat\fR (beta testing)" 9
.IX Item "--cat (beta testing)"
Create a temporary file with content. Normally \fB\-\-pipe\fR/\fB\-\-pipepart\fR
will give data to the program on stdin (standard input). With \fB\-\-cat\fR
\&\s-1GNU \s0\fBparallel\fR will create a temporary file with the name in {}, so
you can do: \fBparallel \-\-pipe \-\-cat wc {}\fR.
.Sp
See also \fB\-\-fifo\fR.
.IP "\fB\-\-cleanup\fR (beta testing)" 9
.IX Item "--cleanup (beta testing)"
Remove transferred files. \fB\-\-cleanup\fR will remove the transferred files
on the remote computer after processing is done.
.Sp
.Vb 3
\&  find log \-name \*(Aq*gz\*(Aq | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer \e
\&    \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip \-9 >{.}.bz2"
.Ve
.Sp
With \fB\-\-transfer\fR the file transferred to the remote computer will be
removed on the remote computer.  Directories created will not be removed
\&\- even if they are empty.
.Sp
With \fB\-\-return\fR the file transferred from the remote computer will be
removed on the remote computer.  Directories created will not be removed
\&\- even if they are empty.
.Sp
\&\fB\-\-cleanup\fR is ignored when not used with \fB\-\-transfer\fR or \fB\-\-return\fR.
.IP "\fB\-\-colsep\fR \fIregexp\fR" 9
.IX Item "--colsep regexp"
.PD 0
.IP "\fB\-C\fR \fIregexp\fR" 9
.IX Item "-C regexp"
.PD
Column separator. The input will be treated as a table with \fIregexp\fR
separating the columns. The n'th column can be access using
\&\fB{\fR\fIn\fR\fB}\fR or \fB{\fR\fIn\fR.\fB}\fR. E.g. \fB{3}\fR is the 3rd column.
.Sp
\&\fB\-\-colsep\fR implies \fB\-\-trim rl\fR.
.Sp
\&\fIregexp\fR is a Perl Regular Expression:
http://perldoc.perl.org/perlre.html
.IP "\fB\-\-compress\fR" 9
.IX Item "--compress"
Compress temporary files. If the output is big and very compressible
this will take up less disk space in \f(CW$TMPDIR\fR and possibly be faster
due to less disk I/O.
.Sp
\&\s-1GNU \s0\fBparallel\fR will try \fBlzop\fR, \fBpigz\fR, \fBgzip\fR, \fBpbzip2\fR,
\&\fBplzip\fR, \fBbzip2\fR, \fBlzma\fR, \fBlzip\fR, \fBxz\fR in that order, and use the
first available.
.IP "\fB\-\-compress\-program\fR \fIprg\fR" 9
.IX Item "--compress-program prg"
.PD 0
.IP "\fB\-\-decompress\-program\fR \fIprg\fR" 9
.IX Item "--decompress-program prg"
.PD
Use \fIprg\fR for (de)compressing temporary files. It is assumed that \fIprg
\&\-dc\fR will decompress stdin (standard input) to stdout (standard
output) unless \fB\-\-decompress\-program\fR is given.
.IP "\fB\-\-ctrlc\fR" 9
.IX Item "--ctrlc"
If receiving \s-1SIGNING, GNU \s0\fBparallel\fR will send \s-1SIGINT\s0 to tasks
running on remote computers thus killing them.
.IP "\fB\-\-delimiter\fR \fIdelim\fR" 9
.IX Item "--delimiter delim"
.PD 0
.IP "\fB\-d\fR \fIdelim\fR" 9
.IX Item "-d delim"
.PD
Input items are terminated by \fIdelim\fR.  Quotes and backslash are not
special; every character in the input is taken literally.  Disables
the end-of-file string, which is treated like any other argument. The
specified delimiter may be characters, C\-style character escapes such
as \en, or octal or hexadecimal escape codes.  Octal and hexadecimal
escape codes are understood as for the printf command.  Multibyte
characters are not supported.
.IP "\fB\-\-dirnamereplace\fR \fIreplace-str\fR" 9
.IX Item "--dirnamereplace replace-str"
.PD 0
.IP "\fB\-\-dnr\fR \fIreplace-str\fR" 9
.IX Item "--dnr replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{//}\fR for
dirname of input line.
.IP "\fB\-E\fR \fIeof-str\fR" 9
.IX Item "-E eof-str"
Set the end of file string to \fIeof-str\fR.  If the end of file string
occurs as a line of input, the rest of the input is not read.  If
neither \fB\-E\fR nor \fB\-e\fR is used, no end of file string is used.
.IP "\fB\-\-delay\fR \fIsecs\fR" 9
.IX Item "--delay secs"
Delay starting next job \fIsecs\fR seconds. \s-1GNU \s0\fBparallel\fR will pause
\&\fIsecs\fR seconds after starting each job. \fIsecs\fR can be less than 1
second.
.IP "\fB\-\-dry\-run\fR" 9
.IX Item "--dry-run"
Print the job to run on stdout (standard output), but do not run the
job. Use \fB\-v \-v\fR to include the wrapping that \s-1GNU\s0 Parallel generates
(for remote jobs, \fB\-\-tmux\fR, \fB\-\-nice\fR, \fB\-\-pipe\fR, \fB\-\-pipepart\fR,
\&\fB\-\-fifo\fR and \fB\-\-cat\fR). Do not count on this literaly, though, as the
job may be scheduled on another computer or the local computer if : is
in the list.
.IP "\fB\-\-eof\fR[=\fIeof-str\fR]" 9
.IX Item "--eof[=eof-str]"
.PD 0
.IP "\fB\-e\fR[\fIeof-str\fR]" 9
.IX Item "-e[eof-str]"
.PD
This option is a synonym for the \fB\-E\fR option.  Use \fB\-E\fR instead,
because it is \s-1POSIX\s0 compliant for \fBxargs\fR while this option is not.
If \fIeof-str\fR is omitted, there is no end of file string.  If neither
\&\fB\-E\fR nor \fB\-e\fR is used, no end of file string is used.
.IP "\fB\-\-env\fR \fIvar\fR (beta testing)" 9
.IX Item "--env var (beta testing)"
Copy environment variable \fIvar\fR. This will copy \fIvar\fR to the
environment that the command is run in. This is especially useful for
remote execution.
.Sp
In Bash \fIvar\fR can also be a Bash function \- just remember to \fBexport
\&\-f\fR the function, see \fBcommand\fR.
.Sp
The variable '_' is special. It will copy all exported environment
variables except for the ones mentioned in ~/.parallel/ignored_vars.
.Sp
To copy Bash arrays you need an importer function, as Bash arrays
cannot be exported:
.Sp
.Vb 8
\&    import_array () {
\&      local func=$1; shift;
\&      export $func=\*(Aq() {
\&        \*(Aq"$(for arr in $@; do
\&              declare \-p $arr|sed \*(Aq1s/declare \-./&g/\*(Aq
\&            done)"\*(Aq
\&      }\*(Aq
\&    }
\&
\&    declare \-A assoc=\*(Aq([one]="1" [two]="2")\*(Aq
\&    declare \-a indexed=\*(Aq([0]="one" [1]="two")\*(Aq
\&
\&    import_array my_importer assoc indexed
\&
\&    parallel \-\-env my_importer \e
\&      \*(Aqmy_importer; echo "{}" "${indexed[{}]}" "${assoc[${indexed[{}]}]}"\*(Aq ::: "${!indexed[@]}"
.Ve
.Sp
To copy the full environment (both exported and not exported variables
and functions) use this function (e.g. by putting it in .bashrc):
.Sp
.Vb 7
\&    env_parallel() {
\&      export parallel_bash_environment="$(echo "shopt \-s expand_aliases 2>/dev/null"; alias;typeset \-p | grep \-vFf <(readonly; echo GROUPS; echo FUNCNAME; echo DIRSTACK; echo _; echo PIPESTATUS; echo USERNAME) | grep \-v BASH_;typeset \-f)";
\&      \`which parallel\` "$@";
\&      unset parallel_bash_environment;
\&    }
\&    # call as:
\&    env_parallel [normal parallel options]
.Ve
.Sp
See also: \fB\-\-record\-env\fR.
.IP "\fB\-\-eta\fR" 9
.IX Item "--eta"
Show the estimated number of seconds before finishing. This forces \s-1GNU
\&\s0\fBparallel\fR to read all jobs before starting to find the number of
jobs. \s-1GNU \s0\fBparallel\fR normally only reads the next job to run.
.Sp
Implies \fB\-\-progress\fR.
.Sp
See also: \fB\-\-bar\fR, \fB\-\-progress\fR.
.IP "\fB\-\-fg\fR" 9
.IX Item "--fg"
Run command in foreground thus \s-1GNU \s0\fBparallel\fR will wait for
completion of the command before exiting.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also \fB\-\-bg\fR, \fBman sem\fR.
.IP "\fB\-\-fifo\fR (beta testing)" 9
.IX Item "--fifo (beta testing)"
Create a temporary fifo with content. Normally \fB\-\-pipe\fR and
\&\fB\-\-pipepart\fR will give data to the program on stdin (standard
input). With \fB\-\-fifo\fR \s-1GNU \s0\fBparallel\fR will create a temporary fifo
with the name in {}, so you can do: \fBparallel \-\-pipe \-\-fifo wc {}\fR.
.Sp
Beware: If data is not read from the fifo, the job will block forever.
.Sp
See also \fB\-\-cat\fR.
.IP "\fB\-\-filter\-hosts\fR" 9
.IX Item "--filter-hosts"
Remove down hosts. For each remote host: check that login through ssh
works. If not: do not use this host.
.Sp
Currently you can \fInot\fR put \fB\-\-filter\-hosts\fR in a profile,
\&\f(CW$PARALLEL\fR, /etc/parallel/config or similar. This is because \s-1GNU
\&\s0\fBparallel\fR uses \s-1GNU \s0\fBparallel\fR to compute this, so you will get an
infinite loop. This will likely be fixed in a later release.
.IP "\fB\-\-gnu\fR" 9
.IX Item "--gnu"
Behave like \s-1GNU \s0\fBparallel\fR. This option historically took precedence
over \fB\-\-tollef\fR. The \fB\-\-tollef\fR option is now retired, and therefore
may not be used. \fB\-\-gnu\fR is kept for compatibility.
.IP "\fB\-\-group\fR" 9
.IX Item "--group"
Group output. Output from each jobs is grouped together and is only
printed when the command is finished. stderr (standard error) first
followed by stdout (standard output). This takes some \s-1CPU\s0 time. In
rare situations \s-1GNU \s0\fBparallel\fR takes up lots of \s-1CPU\s0 time and if it is
acceptable that the outputs from different commands are mixed
together, then disabling grouping with \fB\-u\fR can speedup \s-1GNU
\&\s0\fBparallel\fR by a factor of 10.
.Sp
\&\fB\-\-group\fR is the default. Can be reversed with \fB\-u\fR.
.Sp
See also: \fB\-\-line\-buffer\fR \fB\-\-ungroup\fR
.IP "\fB\-\-help\fR" 9
.IX Item "--help"
.PD 0
.IP "\fB\-h\fR" 9
.IX Item "-h"
.PD
Print a summary of the options to \s-1GNU \s0\fBparallel\fR and exit.
.IP "\fB\-\-halt\-on\-error\fR \fIval\fR (beta testing)" 9
.IX Item "--halt-on-error val (beta testing)"
.PD 0
.IP "\fB\-\-halt\fR \fIval\fR (beta testing)" 9
.IX Item "--halt val (beta testing)"
.PD
How should \s-1GNU \s0\fBparallel\fR terminate?
.RS 9
.IP "0" 7
Do not halt if a job fails. Exit status will be the number of jobs
failed. This is the default.
.IP "1" 7
.IX Item "1"
Do not start new jobs if a job fails, but complete the running jobs
including cleanup. The exit status will be the exit status from the
last failing job.
.IP "2" 7
.IX Item "2"
Kill off all jobs immediately and exit without cleanup. The exit
status will be the exit status from the failing job.
.IP "\-1" 7
.IX Item "-1"
Do not start new jobs if a job succeeds, but complete the running jobs
including cleanup. The exit status will be the exit status from the
last failing job if any.
.IP "\-2" 7
.IX Item "-2"
Kill off all jobs immediately and exit without cleanup. The exit
status will be 0.
.IP "1\-99%" 7
.IX Item "1-99%"
If \fIval\fR% of the jobs fail and minimum 3: Do not start new jobs, but
complete the running jobs including cleanup. The exit status will be
the exit status from the last failing job.
.RE
.RS 9
.RE
.IP "\fB\-\-header\fR \fIregexp\fR" 9
.IX Item "--header regexp"
Use regexp as header. For normal usage the matched header (typically
the first line: \fB\-\-header '.*\en'\fR) will be split using \fB\-\-colsep\fR
(which will default to '\et') and column names can be used as
replacement variables: \fB{column name}\fR.
.Sp
For \fB\-\-pipe\fR the matched header will be prepended to each output.
.Sp
\&\fB\-\-header :\fR is an alias for \fB\-\-header '.*\en'\fR.
.Sp
If \fIregexp\fR is a number, it is a fixed number of lines.
.IP "\fB\-\-hostgroups\fR" 9
.IX Item "--hostgroups"
.PD 0
.IP "\fB\-\-hgrp\fR" 9
.IX Item "--hgrp"
.PD
Enable hostgroups on arguments. If an argument contains '@' the string
after '@' will be removed and treated as a list of hostgroups on which
this job is allowed to run. If there is no \fB\-\-sshlogin\fR with a
corresponding group, the job will run on any hostgroup.
.Sp
Example:
.Sp
.Vb 4
\&  parallel \-\-hostgroups \e
\&    \-\-sshlogin @grp1/myserver1 \-S @grp1+grp2/myserver2 \e
\&    \-\-sshlogin @grp3/myserver3 \e
\&    echo ::: my_grp1_arg@grp1 arg_for_grp2@grp2 third_arg@grp1+grp3
.Ve
.Sp
\&\fBmy_grp1_arg\fR may be run on either \fBmyserver1\fR or \fBmyserver2\fR,
\&\fBthird_arg\fR may be run on either \fBmyserver1\fR or \fBmyserver3\fR,
but \fBarg_for_grp2\fR will only be run on \fBmyserver2\fR.
.IP "\fB\-I\fR \fIreplace-str\fR" 9
.IX Item "-I replace-str"
Use the replacement string \fIreplace-str\fR instead of {}.
.IP "\fB\-\-replace\fR[=\fIreplace-str\fR]" 9
.IX Item "--replace[=replace-str]"
.PD 0
.IP "\fB\-i\fR[\fIreplace-str\fR]" 9
.IX Item "-i[replace-str]"
.PD
This option is a synonym for \fB\-I\fR\fIreplace-str\fR if \fIreplace-str\fR is
specified, and for \fB\-I\fR{} otherwise.  This option is deprecated;
use \fB\-I\fR instead.
.IP "\fB\-\-joblog\fR \fIlogfile\fR" 9
.IX Item "--joblog logfile"
Logfile for executed jobs. Save a list of the executed jobs to
\&\fIlogfile\fR in the following \s-1TAB\s0 separated format: sequence number,
sshlogin, start time as seconds since epoch, run time in seconds,
bytes in files transferred, bytes in files returned, exit status,
signal, and command run.
.Sp
To convert the times into \s-1ISO\-8601\s0 strict do:
.Sp
.Vb 2
\&  perl \-a \-F"\et" \-ne \e
\&    \*(Aqchomp($F[2]=\`date \-d \e@$F[2] +%FT%T\`); print join("\et",@F)\*(Aq
.Ve
.Sp
See also \fB\-\-resume\fR \fB\-\-resume\-failed\fR.
.IP "\fB\-\-jobs\fR \fIN\fR" 9
.IX Item "--jobs N"
.PD 0
.IP "\fB\-j\fR \fIN\fR" 9
.IX Item "-j N"
.IP "\fB\-\-max\-procs\fR \fIN\fR" 9
.IX Item "--max-procs N"
.IP "\fB\-P\fR \fIN\fR" 9
.IX Item "-P N"
.PD
Number of jobslots. Run up to N jobs in parallel.  0 means as many as
possible. Default is 100% which will run one job per \s-1CPU\s0 core.
.Sp
If \fB\-\-semaphore\fR is set default is 1 thus making a mutex.
.IP "\fB\-\-jobs\fR \fI+N\fR" 9
.IX Item "--jobs +N"
.PD 0
.IP "\fB\-j\fR \fI+N\fR" 9
.IX Item "-j +N"
.IP "\fB\-\-max\-procs\fR \fI+N\fR" 9
.IX Item "--max-procs +N"
.IP "\fB\-P\fR \fI+N\fR" 9
.IX Item "-P +N"
.PD
Add N to the number of \s-1CPU\s0 cores.  Run this many jobs in parallel.
See also \fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fI\-N\fR" 9
.IX Item "--jobs -N"
.PD 0
.IP "\fB\-j\fR \fI\-N\fR" 9
.IX Item "-j -N"
.IP "\fB\-\-max\-procs\fR \fI\-N\fR" 9
.IX Item "--max-procs -N"
.IP "\fB\-P\fR \fI\-N\fR" 9
.IX Item "-P -N"
.PD
Subtract N from the number of \s-1CPU\s0 cores.  Run this many jobs in parallel.
If the evaluated number is less than 1 then 1 will be used.  See also
\&\fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fIN\fR%" 9
.IX Item "--jobs N%"
.PD 0
.IP "\fB\-j\fR \fIN\fR%" 9
.IX Item "-j N%"
.IP "\fB\-\-max\-procs\fR \fIN\fR%" 9
.IX Item "--max-procs N%"
.IP "\fB\-P\fR \fIN\fR%" 9
.IX Item "-P N%"
.PD
Multiply N% with the number of \s-1CPU\s0 cores.  Run this many jobs in
parallel. See also \fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fIprocfile\fR" 9
.IX Item "--jobs procfile"
.PD 0
.IP "\fB\-j\fR \fIprocfile\fR" 9
.IX Item "-j procfile"
.IP "\fB\-\-max\-procs\fR \fIprocfile\fR" 9
.IX Item "--max-procs procfile"
.IP "\fB\-P\fR \fIprocfile\fR" 9
.IX Item "-P procfile"
.PD
Read parameter from file. Use the content of \fIprocfile\fR as parameter
for \fI\-j\fR. E.g. \fIprocfile\fR could contain the string 100% or +2 or
10. If \fIprocfile\fR is changed when a job completes, \fIprocfile\fR is
read again and the new number of jobs is computed. If the number is
lower than before, running jobs will be allowed to finish but new jobs
will not be started until the wanted number of jobs has been reached.
This makes it possible to change the number of simultaneous running
jobs while \s-1GNU \s0\fBparallel\fR is running.
.IP "\fB\-\-keep\-order\fR" 9
.IX Item "--keep-order"
.PD 0
.IP "\fB\-k\fR" 9
.IX Item "-k"
.PD
Keep sequence of output same as the order of input. Normally the
output of a job will be printed as soon as the job completes. Try this
to see the difference:
.Sp
.Vb 2
\&  parallel \-j4 sleep {}\e; echo {} ::: 2 1 4 3
\&  parallel \-j4 \-k sleep {}\e; echo {} ::: 2 1 4 3
.Ve
.Sp
If used with \fB\-\-onall\fR or \fB\-\-nonall\fR the output will grouped by
sshlogin in sorted order.
.IP "\fB\-L\fR \fImax-lines\fR" 9
.IX Item "-L max-lines"
When used with \fB\-\-pipe\fR: Read records of \fImax-lines\fR.
.Sp
When used otherwise: Use at most \fImax-lines\fR nonblank input lines per
command line.  Trailing blanks cause an input line to be logically
continued on the next input line.
.Sp
\&\fB\-L 0\fR means read one line, but insert 0 arguments on the command
line.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.IP "\fB\-\-max\-lines\fR[=\fImax-lines\fR]" 9
.IX Item "--max-lines[=max-lines]"
.PD 0
.IP "\fB\-l\fR[\fImax-lines\fR]" 9
.IX Item "-l[max-lines]"
.PD
When used with \fB\-\-pipe\fR: Read records of \fImax-lines\fR.
.Sp
When used otherwise: Synonym for the \fB\-L\fR option.  Unlike \fB\-L\fR, the
\&\fImax-lines\fR argument is optional.  If \fImax-lines\fR is not specified,
it defaults to one.  The \fB\-l\fR option is deprecated since the \s-1POSIX\s0
standard specifies \fB\-L\fR instead.
.Sp
\&\fB\-l 0\fR is an alias for \fB\-l 1\fR.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.IP "\fB\-\-line\-buffer\fR" 9
.IX Item "--line-buffer"
Buffer output on line basis. \fB\-\-group\fR will keep the output together
for a whole job. \fB\-\-ungroup\fR allows output to mixup with half a line
coming from one job and half a line coming from another
job. \fB\-\-line\-buffer\fR fits between these two: \s-1GNU \s0\fBparallel\fR will
print a full line, but will allow for mixing lines of different jobs.
.Sp
\&\fB\-\-line\-buffer\fR takes more \s-1CPU\s0 power than than both \fB\-\-group\fR and
\&\fB\-\-ungroup\fR, but can be faster than \fB\-\-group\fR if the \s-1CPU\s0 is not the
limiting factor.
.Sp
See also: \fB\-\-group\fR \fB\-\-ungroup\fR
.IP "\fB\-\-load\fR \fImax-load\fR (beta testing)" 9
.IX Item "--load max-load (beta testing)"
Do not start new jobs on a given computer unless the number of running
processes on the computer is less than \fImax-load\fR. \fImax-load\fR uses
the same syntax as \fB\-\-jobs\fR, so \fI100%\fR for one per \s-1CPU\s0 is a valid
setting. Only difference is 0 which is interpreted as 0.01.
.IP "\fB\-\-controlmaster\fR" 9
.IX Item "--controlmaster"
.PD 0
.IP "\fB\-M\fR" 9
.IX Item "-M"
.PD
Use ssh's ControlMaster to make ssh connections faster. Useful if jobs
run remote and are very fast to run. This is disabled for sshlogins
that specify their own ssh command.
.IP "\fB\-\-xargs\fR" 9
.IX Item "--xargs"
Multiple arguments. Insert as many arguments as the command line
length permits.
.Sp
If \fB{}\fR is not used the arguments will be appended to the
line.  If \fB{}\fR is used multiple times each \fB{}\fR will be replaced
with all the arguments.
.Sp
Support for \fB\-\-xargs\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
See also \fB\-X\fR for context replace. If in doubt use \fB\-X\fR as that will
most likely do what is needed.
.IP "\fB\-m\fR" 9
.IX Item "-m"
Multiple arguments. Insert as many arguments as the command line
length permits. If multiple jobs are being run in parallel: distribute
the arguments evenly among the jobs. Use \fB\-j1\fR to avoid this.
.Sp
If \fB{}\fR is not used the arguments will be appended to the
line.  If \fB{}\fR is used multiple times each \fB{}\fR will be replaced
with all the arguments.
.Sp
Support for \fB\-m\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
See also \fB\-X\fR for context replace. If in doubt use \fB\-X\fR as that will
most likely do what is needed.
.IP "\fB\-\-memfree\fR \fIsize\fR (beta testing)" 9
.IX Item "--memfree size (beta testing)"
Minimum memory free when starting another job. The \fIsize\fR can be
postfixed with K, M, G, T, P, k, m, g, t, or p which would multiply
the size with 1024, 1048576, 1073741824, 1099511627776,
1125899906842624, 1000, 1000000, 1000000000, 1000000000000, or
1000000000000000 respectively.
.Sp
If the jobs take up very different amount of \s-1RAM, GNU \s0\fBparallel\fR will
only start as many as there is memory for. If less than \fIsize\fR bytes
are free, no more jobs will be started. If less than 50% \fIsize\fR bytes
are free, the youngest job will be killed, and put back on the queue
to be run later.
.IP "\fB\-\-minversion\fR \fIversion\fR" 9
.IX Item "--minversion version"
Print the version \s-1GNU \s0\fBparallel\fR and exit.  If the current version of
\&\s-1GNU \s0\fBparallel\fR is less than \fIversion\fR the exit code is
255. Otherwise it is 0.
.Sp
This is useful for scripts that depend on features only available from
a certain version of \s-1GNU \s0\fBparallel\fR.
.IP "\fB\-\-nonall\fR" 9
.IX Item "--nonall"
\&\fB\-\-onall\fR with no arguments. Run the command on all computers given
with \fB\-\-sshlogin\fR but take no arguments. \s-1GNU \s0\fBparallel\fR will log
into \fB\-\-jobs\fR number of computers in parallel and run the job on the
computer. \fB\-j\fR adjusts how many computers to log into in parallel.
.Sp
This is useful for running the same command (e.g. uptime) on a list of
servers.
.IP "\fB\-\-onall\fR" 9
.IX Item "--onall"
Run all the jobs on all computers given with \fB\-\-sshlogin\fR. \s-1GNU
\&\s0\fBparallel\fR will log into \fB\-\-jobs\fR number of computers in parallel
and run one job at a time on the computer. The order of the jobs will
not be changed, but some computers may finish before others.
.Sp
When using \fB\-\-group\fR the output will be grouped by each server, so
all the output from one server will be grouped together.
.Sp
\&\fB\-\-joblog\fR will contain an entry for each job on each server, so
there will be several job sequence 1.
.IP "\fB\-\-output\-as\-files\fR" 9
.IX Item "--output-as-files"
.PD 0
.IP "\fB\-\-outputasfiles\fR" 9
.IX Item "--outputasfiles"
.IP "\fB\-\-files\fR" 9
.IX Item "--files"
.PD
Instead of printing the output to stdout (standard output) the output
of each job is saved in a file and the filename is then printed.
.Sp
See also: \fB\-\-results\fR
.IP "\fB\-\-pipe\fR" 9
.IX Item "--pipe"
.PD 0
.IP "\fB\-\-spreadstdin\fR" 9
.IX Item "--spreadstdin"
.PD
Spread input to jobs on stdin (standard input). Read a block of data
from stdin (standard input) and give one block of data as input to one
job.
.Sp
The block size is determined by \fB\-\-block\fR. The strings \fB\-\-recstart\fR
and \fB\-\-recend\fR tell \s-1GNU \s0\fBparallel\fR how a record starts and/or
ends. The block read will have the final partial record removed before
the block is passed on to the job. The partial record will be
prepended to next block.
.Sp
If \fB\-\-recstart\fR is given this will be used to split at record start.
.Sp
If \fB\-\-recend\fR is given this will be used to split at record end.
.Sp
If both \fB\-\-recstart\fR and \fB\-\-recend\fR are given both will have to
match to find a split position.
.Sp
If neither \fB\-\-recstart\fR nor \fB\-\-recend\fR are given \fB\-\-recend\fR
defaults to '\en'. To have no record separator use \fB\-\-recend ""\fR.
.Sp
\&\fB\-\-files\fR is often used with \fB\-\-pipe\fR.
.Sp
See also: \fB\-\-recstart\fR, \fB\-\-recend\fR, \fB\-\-fifo\fR, \fB\-\-cat\fR, \fB\-\-pipepart\fR.
.IP "\fB\-\-pipepart\fR" 9
.IX Item "--pipepart"
Pipe parts of a physical file. \fB\-\-pipepart\fR works similar to
\&\fB\-\-pipe\fR, but is much faster. It has a few limitations:
.RS 9
.IP "*" 3
The file must be a physical (seekable) file and must be given using \fB\-a\fR or \fB::::\fR.
.IP "*" 3
Record counting (\fB\-N\fR) and line counting (\fB\-L\fR/\fB\-l\fR) do not work.
.RE
.RS 9
.RE
.IP "\fB\-\-plain\fR" 9
.IX Item "--plain"
Ignore any \fB\-\-profile\fR, \f(CW$PARALLEL\fR, and ~/.parallel/config to get full
control on the command line (used by \s-1GNU \s0\fBparallel\fR internally when
called with \fB\-\-sshlogin\fR).
.IP "\fB\-\-plus\fR" 9
.IX Item "--plus"
Activate additional replacement strings: {+/} {+.} {+..} {+...} {..}
{...} {/..} {/...}. The idea being that '{+foo}' matches the opposite of
\&'{foo}' and {} = {+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.} = {..}.{+..} =
{+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}
.IP "\fB\-\-progress\fR" 9
.IX Item "--progress"
Show progress of computations. List the computers involved in the task
with number of \s-1CPU\s0 cores detected and the max number of jobs to
run. After that show progress for each computer: number of running
jobs, number of completed jobs, and percentage of all jobs done by
this computer. The percentage will only be available after all jobs
have been scheduled as \s-1GNU \s0\fBparallel\fR only read the next job when
ready to schedule it \- this is to avoid wasting time and memory by
reading everything at startup.
.Sp
By sending \s-1GNU \s0\fBparallel\fR \s-1SIGUSR2\s0 you can toggle turning on/off
\&\fB\-\-progress\fR on a running \s-1GNU \s0\fBparallel\fR process.
.Sp
See also \fB\-\-eta\fR.
.IP "\fB\-\-max\-args\fR=\fImax-args\fR" 9
.IX Item "--max-args=max-args"
.PD 0
.IP "\fB\-n\fR \fImax-args\fR" 9
.IX Item "-n max-args"
.PD
Use at most \fImax-args\fR arguments per command line.  Fewer than
\&\fImax-args\fR arguments will be used if the size (see the \fB\-s\fR option)
is exceeded, unless the \fB\-x\fR option is given, in which case
\&\s-1GNU \s0\fBparallel\fR will exit.
.Sp
\&\fB\-n 0\fR means read one argument, but insert 0 arguments on the command
line.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR is set.
.IP "\fB\-\-max\-replace\-args\fR=\fImax-args\fR" 9
.IX Item "--max-replace-args=max-args"
.PD 0
.IP "\fB\-N\fR \fImax-args\fR" 9
.IX Item "-N max-args"
.PD
Use at most \fImax-args\fR arguments per command line. Like \fB\-n\fR but
also makes replacement strings \fB{1}\fR .. \fB{\fR\fImax-args\fR\fB}\fR that
represents argument 1 .. \fImax-args\fR. If too few args the \fB{\fR\fIn\fR\fB}\fR will
be empty.
.Sp
\&\fB\-N 0\fR means read one argument, but insert 0 arguments on the command
line.
.Sp
This will set the owner of the homedir to the user:
.Sp
.Vb 1
\&  tr \*(Aq:\*(Aq \*(Aq\en\*(Aq < /etc/passwd | parallel \-N7 chown {1} {6}
.Ve
.Sp
Implies \fB\-X\fR unless \fB\-m\fR or \fB\-\-pipe\fR is set.
.Sp
When used with \fB\-\-pipe\fR \fB\-N\fR is the number of records to read. This
is somewhat slower than \fB\-\-block\fR.
.IP "\fB\-\-max\-line\-length\-allowed\fR" 9
.IX Item "--max-line-length-allowed"
Print the maximal number of characters allowed on the command line and
exit (used by \s-1GNU \s0\fBparallel\fR itself to determine the line length
on remote computers).
.IP "\fB\-\-number\-of\-cpus\fR" 9
.IX Item "--number-of-cpus"
Print the number of physical CPUs and exit (used by \s-1GNU \s0\fBparallel\fR
itself to determine the number of physical CPUs on remote computers).
.IP "\fB\-\-number\-of\-cores\fR" 9
.IX Item "--number-of-cores"
Print the number of \s-1CPU\s0 cores and exit (used by \s-1GNU \s0\fBparallel\fR itself
to determine the number of \s-1CPU\s0 cores on remote computers).
.IP "\fB\-\-no\-keep\-order\fR  (beta testing)" 9
.IX Item "--no-keep-order (beta testing)"
Overrides an earlier \fB\-\-keep\-order\fR (e.g. if set in
\&\fB~/.parallel/config\fR).
.IP "\fB\-\-no\-notice\fR" 9
.IX Item "--no-notice"
Do not display citation notice. A citation notice is printed on stderr
(standard error) only if stderr (standard error) is a terminal, the
user has not specified \fB\-\-no\-notice\fR, and the user has not run
\&\fB\-\-bibtex\fR once.
.IP "\fB\-\-nice\fR \fIniceness\fR" 9
.IX Item "--nice niceness"
Run the command at this niceness. For simple commands you can just add
\&\fBnice\fR in front of the command. But if the command consists of more
sub commands (Like: ls|wc) then prepending \fBnice\fR will not always
work. \fB\-\-nice\fR will make sure all sub commands are niced \- even on
remote servers.
.IP "\fB\-\-interactive\fR" 9
.IX Item "--interactive"
.PD 0
.IP "\fB\-p\fR" 9
.IX Item "-p"
.PD
Prompt the user about whether to run each command line and read a line
from the terminal.  Only run the command line if the response starts
with 'y' or 'Y'.  Implies \fB\-t\fR.
.IP "\fB\-\-parens\fR \fIparensstring\fR" 9
.IX Item "--parens parensstring"
Use to define start and end parenthesis for \fB{= perl expression =}\fR. The
left and the right parenthesis can be multiple characters and are
assumed to be the same length. The default is \fB{==}\fR giving
\&\fB{=\fR as the start parenthesis and \fB=}\fR as the end parenthesis.
.Sp
Another useful setting is \fB,,,,\fR which would make both parenthesis
\&\fB,,\fR:
.Sp
.Vb 1
\&  parallel \-\-parens ,,,, echo foo is ,,s/I/O/g,, ::: FII
.Ve
.Sp
See also: \fB\-\-rpl\fR \fB{= perl expression =}\fR
.IP "\fB\-\-profile\fR \fIprofilename\fR" 9
.IX Item "--profile profilename"
.PD 0
.IP "\fB\-J\fR \fIprofilename\fR" 9
.IX Item "-J profilename"
.PD
Use profile \fIprofilename\fR for options. This is useful if you want to
have multiple profiles. You could have one profile for running jobs in
parallel on the local computer and a different profile for running jobs
on remote computers. See the section \s-1PROFILE FILES\s0 for examples.
.Sp
\&\fIprofilename\fR corresponds to the file ~/.parallel/\fIprofilename\fR.
.Sp
You can give multiple profiles by repeating \fB\-\-profile\fR. If parts of
the profiles conflict, the later ones will be used.
.Sp
Default: config
.IP "\fB\-\-quote\fR" 9
.IX Item "--quote"
.PD 0
.IP "\fB\-q\fR" 9
.IX Item "-q"
.PD
Quote \fIcommand\fR.  This will quote the command line so special
characters are not interpreted by the shell. See the section
\&\s-1QUOTING.\s0 Most people will never need this.  Quoting is disabled by
default.
.IP "\fB\-\-no\-run\-if\-empty\fR" 9
.IX Item "--no-run-if-empty"
.PD 0
.IP "\fB\-r\fR" 9
.IX Item "-r"
.PD
If the stdin (standard input) only contains whitespace, do not run the command.
.Sp
If used with \fB\-\-pipe\fR this is slow.
.IP "\fB\-\-noswap\fR" 9
.IX Item "--noswap"
Do not start new jobs on a given computer if there is both swap-in and
swap-out activity.
.Sp
The swap activity is only sampled every 10 seconds as the sampling
takes 1 second to do.
.Sp
Swap activity is computed as (swap\-in)*(swap\-out) which in practice is
a good value: swapping out is not a problem, swapping in is not a
problem, but both swapping in and out usually indicates a problem.
.IP "\fB\-\-record\-env\fR" 9
.IX Item "--record-env"
Record current environment variables in ~/.parallel/ignored_vars. This
is useful before using \fB\-\-env _\fR.
.Sp
See also \fB\-\-env\fR.
.IP "\fB\-\-recstart\fR \fIstartstring\fR" 9
.IX Item "--recstart startstring"
.PD 0
.IP "\fB\-\-recend\fR \fIendstring\fR" 9
.IX Item "--recend endstring"
.PD
If \fB\-\-recstart\fR is given \fIstartstring\fR will be used to split at record start.
.Sp
If \fB\-\-recend\fR is given \fIendstring\fR will be used to split at record end.
.Sp
If both \fB\-\-recstart\fR and \fB\-\-recend\fR are given the combined string
\&\fIendstring\fR\fIstartstring\fR will have to match to find a split
position. This is useful if either \fIstartstring\fR or \fIendstring\fR
match in the middle of a record.
.Sp
If neither \fB\-\-recstart\fR nor \fB\-\-recend\fR are given then \fB\-\-recend\fR
defaults to '\en'. To have no record separator use \fB\-\-recend ""\fR.
.Sp
\&\fB\-\-recstart\fR and \fB\-\-recend\fR are used with \fB\-\-pipe\fR.
.Sp
Use \fB\-\-regexp\fR to interpret \fB\-\-recstart\fR and \fB\-\-recend\fR as regular
expressions. This is slow, however.
.IP "\fB\-\-regexp\fR" 9
.IX Item "--regexp"
Use \fB\-\-regexp\fR to interpret \fB\-\-recstart\fR and \fB\-\-recend\fR as regular
expressions. This is slow, however.
.IP "\fB\-\-remove\-rec\-sep\fR" 9
.IX Item "--remove-rec-sep"
.PD 0
.IP "\fB\-\-removerecsep\fR" 9
.IX Item "--removerecsep"
.IP "\fB\-\-rrs\fR" 9
.IX Item "--rrs"
.PD
Remove the text matched by \fB\-\-recstart\fR and \fB\-\-recend\fR before piping
it to the command.
.Sp
Only used with \fB\-\-pipe\fR.
.IP "\fB\-\-results\fR \fIprefix\fR" 9
.IX Item "--results prefix"
.PD 0
.IP "\fB\-\-res\fR \fIprefix\fR" 9
.IX Item "--res prefix"
.PD
Save the output into files. The files will be stored in a directory tree
rooted at \fIprefix\fR.  Within this directory tree, each command will result
in two files: \fIprefix\fR/<\s-1ARGS\s0>/stdout and \fIprefix\fR/<\s-1ARGS\s0>/stderr, where
<\s-1ARGS\s0> is a sequence of directories representing the header of the input
source (if using \fB\-\-header :\fR) or the number of the input source and
corresponding values.
.Sp
E.g:
.Sp
.Vb 2
\&  parallel \-\-header : \-\-results foo echo {a} {b} \e
\&    ::: a I II ::: b III IIII
.Ve
.Sp
will generate the files:
.Sp
.Vb 8
\&  foo/a/I/b/III/stderr
\&  foo/a/I/b/III/stdout
\&  foo/a/I/b/IIII/stderr
\&  foo/a/I/b/IIII/stdout
\&  foo/a/II/b/III/stderr
\&  foo/a/II/b/III/stdout
\&  foo/a/II/b/IIII/stderr
\&  foo/a/II/b/IIII/stdout
.Ve
.Sp
and
.Sp
.Vb 1
\&  parallel \-\-results foo echo {1} {2} ::: I II ::: III IIII
.Ve
.Sp
will generate the files:
.Sp
.Vb 8
\&  foo/1/I/2/III/stderr
\&  foo/1/I/2/III/stdout
\&  foo/1/I/2/IIII/stderr
\&  foo/1/I/2/IIII/stdout
\&  foo/1/II/2/III/stderr
\&  foo/1/II/2/III/stdout
\&  foo/1/II/2/IIII/stderr
\&  foo/1/II/2/IIII/stdout
.Ve
.Sp
See also \fB\-\-files\fR, \fB\-\-header\fR, \fB\-\-joblog\fR.
.IP "\fB\-\-resume\fR" 9
.IX Item "--resume"
Resumes from the last unfinished job. By reading \fB\-\-joblog\fR or the
\&\fB\-\-results\fR dir \s-1GNU \s0\fBparallel\fR will figure out the last unfinished
job and continue from there. As \s-1GNU \s0\fBparallel\fR only looks at the
sequence numbers in \fB\-\-joblog\fR then the input, the command, and
\&\fB\-\-joblog\fR all have to remain unchanged; otherwise \s-1GNU \s0\fBparallel\fR
may run wrong commands.
.Sp
See also \fB\-\-joblog\fR, \fB\-\-results\fR, \fB\-\-resume\-failed\fR.
.IP "\fB\-\-resume\-failed\fR" 9
.IX Item "--resume-failed"
Retry all failed and resume from the last unfinished job. By reading
\&\fB\-\-joblog\fR \s-1GNU \s0\fBparallel\fR will figure out the failed jobs and run
those again. After that it will resume last unfinished job and
continue from there. As \s-1GNU \s0\fBparallel\fR only looks at the sequence
numbers in \fB\-\-joblog\fR then the input, the command, and \fB\-\-joblog\fR
all have to remain unchanged; otherwise \s-1GNU \s0\fBparallel\fR may run wrong
commands.
.Sp
See also \fB\-\-joblog\fR, \fB\-\-resume\fR.
.IP "\fB\-\-retries\fR \fIn\fR" 9
.IX Item "--retries n"
If a job fails, retry it on another computer on which it has not
failed. Do this \fIn\fR times. If there are fewer than \fIn\fR computers in
\&\fB\-\-sshlogin\fR \s-1GNU \s0\fBparallel\fR will re-use all the computers. This is
useful if some jobs fail for no apparent reason (such as network
failure).
.IP "\fB\-\-return\fR \fIfilename\fR (alpha testing)" 9
.IX Item "--return filename (alpha testing)"
Transfer files from remote computers. \fB\-\-return\fR is used with
\&\fB\-\-sshlogin\fR when the arguments are files on the remote computers. When
processing is done the file \fIfilename\fR will be transferred
from the remote computer using \fBrsync\fR and will be put relative to
the default login dir. E.g.
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \-\-return {.}.out \e
\&    \-\-sshlogin server.example.com touch {.}.out
.Ve
.Sp
This will transfer the file \fI\f(CI$HOME\fI/foo/bar.out\fR from the computer
\&\fIserver.example.com\fR to the file \fIfoo/bar.out\fR after running
\&\fBtouch foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \-\-return {.}.out \e
\&    \-\-sshlogin server.example.com touch {.}.out
.Ve
.Sp
This will transfer the file \fI/tmp/foo/bar.out\fR from the computer
\&\fIserver.example.com\fR to the file \fI/tmp/foo/bar.out\fR after running
\&\fBtouch /tmp/foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
Multiple files can be transferred by repeating the options multiple
times:
.Sp
.Vb 3
\&  echo /tmp/foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \e
\&    \-\-return {.}.out \-\-return {.}.out2 touch {.}.out {.}.out2
.Ve
.Sp
\&\fB\-\-return\fR is often used with \fB\-\-transfer\fR and \fB\-\-cleanup\fR.
.Sp
\&\fB\-\-return\fR is ignored when used with \fB\-\-sshlogin :\fR or when not used
with \fB\-\-sshlogin\fR.
.IP "\fB\-\-round\-robin\fR" 9
.IX Item "--round-robin"
.PD 0
.IP "\fB\-\-round\fR" 9
.IX Item "--round"
.PD
Normally \fB\-\-pipe\fR will give a single block to each instance of the
command. With \fB\-\-round\-robin\fR all blocks will at random be written to
commands already running. This is useful if the command takes a long
time to initialize.
.Sp
\&\fB\-\-keep\-order\fR will not work with \fB\-\-round\-robin\fR as it is
impossible to track which input block corresponds to which output.
.IP "\fB\-\-rpl\fR '\fItag\fR \fIperl expression\fR'" 9
.IX Item "--rpl 'tag perl expression'"
Use \fItag\fR as a replacement string for \fIperl expression\fR. This makes
it possible to define your own replacement strings. \s-1GNU \s0\fBparallel\fR's
7 replacement strings are implemented as:
.Sp
.Vb 7
\&  \-\-rpl \*(Aq{} \*(Aq
\&  \-\-rpl \*(Aq{#} 1 $_=$job\->seq()\*(Aq
\&  \-\-rpl \*(Aq{%} 1 $_=$job\->slot()\*(Aq
\&  \-\-rpl \*(Aq{/} s:.*/::\*(Aq
\&  \-\-rpl \*(Aq{//} $Global::use{"File::Basename"} ||= eval "use File::Basename; 1;"; $_ = dirname($_);\*(Aq
\&  \-\-rpl \*(Aq{/.} s:.*/::; s:\e.[^/.]+$::;\*(Aq
\&  \-\-rpl \*(Aq{.} s:\e.[^/.]+$::\*(Aq
.Ve
.Sp
If the user defined replacement string starts with '{' it can also be
used as a positional replacement string (like \fB{2.}\fR).
.Sp
It is recommended to only change \f(CW$_\fR but you have full access to all
of \s-1GNU \s0\fBparallel\fR's internal functions and data structures.
.Sp
Here are a few examples:
.Sp
.Vb 6
\&  Remove 2 extensions (e.g. .tar.gz)
\&  \-\-rpl \*(Aq{..} s:\e.[^/.]+$::;s:\e.[^/.]+$::;\*(Aq
\&  Keep only the extension
\&  \-\-rpl \*(Aq{ext} s:.*\e.::\*(Aq
\&  Is the job sequence even or odd?
\&  \-\-rpl \*(Aq{odd} $_=$job\->seq()%2?"odd":"even"\*(Aq
.Ve
.Sp
See also: \fB{= perl expression =}\fR \fB\-\-parens\fR
.IP "\fB\-\-max\-chars\fR=\fImax-chars\fR" 9
.IX Item "--max-chars=max-chars"
.PD 0
.IP "\fB\-s\fR \fImax-chars\fR" 9
.IX Item "-s max-chars"
.PD
Use at most \fImax-chars\fR characters per command line, including the
command and initial-arguments and the terminating nulls at the ends of
the argument strings.  The largest allowed value is system-dependent,
and is calculated as the argument length limit for exec, less the size
of your environment.  The default value is the maximum.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR is set.
.IP "\fB\-\-show\-limits\fR" 9
.IX Item "--show-limits"
Display the limits on the command-line length which are imposed by the
operating system and the \fB\-s\fR option.  Pipe the input from /dev/null
(and perhaps specify \-\-no\-run\-if\-empty) if you don't want \s-1GNU \s0\fBparallel\fR
to do anything.
.IP "\fB\-\-semaphore\fR (beta testing)" 9
.IX Item "--semaphore (beta testing)"
Work as a counting semaphore. \fB\-\-semaphore\fR will cause \s-1GNU
\&\s0\fBparallel\fR to start \fIcommand\fR in the background. When the number of
simultaneous jobs is reached, \s-1GNU \s0\fBparallel\fR will wait for one of
these to complete before starting another command.
.Sp
\&\fB\-\-semaphore\fR implies \fB\-\-bg\fR unless \fB\-\-fg\fR is specified.
.Sp
\&\fB\-\-semaphore\fR implies \fB\-\-semaphorename `tty`\fR unless
\&\fB\-\-semaphorename\fR is specified.
.Sp
Used with \fB\-\-fg\fR, \fB\-\-wait\fR, and \fB\-\-semaphorename\fR.
.Sp
The command \fBsem\fR is an alias for \fBparallel \-\-semaphore\fR.
.Sp
See also \fBman sem\fR.
.IP "\fB\-\-semaphorename\fR \fIname\fR" 9
.IX Item "--semaphorename name"
.PD 0
.IP "\fB\-\-id\fR \fIname\fR" 9
.IX Item "--id name"
.PD
Use \fBname\fR as the name of the semaphore. Default is the name of the
controlling tty (output from \fBtty\fR).
.Sp
The default normally works as expected when used interactively, but
when used in a script \fIname\fR should be set. \fI$$\fR or \fImy_task_name\fR
are often a good value.
.Sp
The semaphore is stored in ~/.parallel/semaphores/
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also \fBman sem\fR.
.IP "\fB\-\-semaphoretimeout\fR \fIsecs\fR (beta testing)" 9
.IX Item "--semaphoretimeout secs (beta testing)"
.PD 0
.IP "\fB\-\-st\fR \fIsecs\fR (beta testing)" 9
.IX Item "--st secs (beta testing)"
.PD
If \fIsecs\fR > 0: If the semaphore is not released within \fIsecs\fR seconds, take it anyway.
.Sp
If \fIsecs\fR < 0: If the semaphore is not released within \fIsecs\fR seconds, exit.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also \fBman sem\fR.
.IP "\fB\-\-seqreplace\fR \fIreplace-str\fR" 9
.IX Item "--seqreplace replace-str"
Use the replacement string \fIreplace-str\fR instead of \fB{#}\fR for
job sequence number.
.IP "\fB\-\-shebang\fR" 9
.IX Item "--shebang"
.PD 0
.IP "\fB\-\-hashbang\fR" 9
.IX Item "--hashbang"
.PD
\&\s-1GNU \s0\fBparallel\fR can be called as a shebang (#!) command as the first
line of a script. The content of the file will be treated as
inputsource.
.Sp
Like this:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang \-r traceroute
\&
\&  foss.org.my
\&  debian.org
\&  freenetproject.org
.Ve
.Sp
\&\fB\-\-shebang\fR must be set as the first option.
.Sp
On FreeBSD \fBenv\fR is needed:
.Sp
.Vb 1
\&  #!/usr/bin/env \-S parallel \-\-shebang \-r traceroute
\&
\&  foss.org.my
\&  debian.org
\&  freenetproject.org
.Ve
.Sp
There are many limitations of shebang (#!) depending on your operating
system. See details on http://www.in\-ulm.de/~mascheck/various/shebang/
.IP "\fB\-\-shebang\-wrap\fR" 9
.IX Item "--shebang-wrap"
\&\s-1GNU \s0\fBparallel\fR can parallelize scripts by wrapping the shebang
line. If the program can be run like this:
.Sp
.Vb 1
\&  cat arguments | parallel the_program
.Ve
.Sp
then the script can be changed to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /the/original/parser \-\-with\-options
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/python
.Ve
.Sp
If the program can be run like this:
.Sp
.Vb 1
\&  cat data | parallel \-\-pipe the_program
.Ve
.Sp
then the script can be changed to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /the/original/parser \-\-with\-options
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /usr/bin/perl \-w
.Ve
.Sp
\&\fB\-\-shebang\-wrap\fR must be set as the first option.
.IP "\fB\-\-shellquote\fR" 9
.IX Item "--shellquote"
Does not run the command but quotes it. Useful for making quoted
composed commands for \s-1GNU \s0\fBparallel\fR.
.IP "\fB\-\-skip\-first\-line\fR" 9
.IX Item "--skip-first-line"
Do not use the first line of input (used by \s-1GNU \s0\fBparallel\fR itself
when called with \fB\-\-shebang\fR).
.IP "\fB\-\-sshdelay\fR \fIsecs\fR" 9
.IX Item "--sshdelay secs"
Delay starting next ssh by \fIsecs\fR seconds. \s-1GNU \s0\fBparallel\fR will pause
\&\fIsecs\fR seconds after starting each ssh. \fIsecs\fR can be less than 1
seconds.
.IP "\fB\-S\fR \fI[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]\fR (beta testing)" 9
.IX Item "-S [@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]] (beta testing)"
.PD 0
.IP "\fB\-\-sshlogin\fR \fI[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]\fR (beta testing)" 9
.IX Item "--sshlogin [@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]] (beta testing)"
.PD
Distribute jobs to remote computers. The jobs will be run on a list of
remote computers.
.Sp
If \fIhostgroups\fR is given, the \fIsshlogin\fR will be added to that
hostgroup. Multiple hostgroups are separated by '+'. The \fIsshlogin\fR
will always be added to a hostgroup named the same as \fIsshlogin\fR.
.Sp
If only the \fIhostgroups\fR is given, only the sshlogins in those
hostgroups will be used.
.Sp
\&\s-1GNU \s0\fBparallel\fR will determine the number of \s-1CPU\s0 cores on the remote
computers and run the number of jobs as specified by \fB\-j\fR.  If the
number \fIncpu\fR is given \s-1GNU \s0\fBparallel\fR will use this number for
number of \s-1CPU\s0 cores on the host. Normally \fIncpu\fR will not be needed.
.Sp
An \fIsshlogin\fR is of the form:
.Sp
.Vb 1
\&  [sshcommand [options]] [username@]hostname
.Ve
.Sp
The sshlogin must not require a password.
.Sp
The sshlogin ':' is special, it means 'no ssh' and will therefore run
on the local computer.
.Sp
The sshlogin '..' is special, it read sshlogins from ~/.parallel/sshloginfile
.Sp
The sshlogin '\-' is special, too, it read sshlogins from stdin
(standard input).
.Sp
To specify more sshlogins separate the sshlogins by comma or repeat
the options multiple times.
.Sp
For examples: see \fB\-\-sshloginfile\fR.
.Sp
The remote host must have \s-1GNU \s0\fBparallel\fR installed.
.Sp
\&\fB\-\-sshlogin\fR is known to cause problems with \fB\-m\fR and \fB\-X\fR.
.Sp
\&\fB\-\-sshlogin\fR is often used with \fB\-\-transfer\fR, \fB\-\-return\fR,
\&\fB\-\-cleanup\fR, and \fB\-\-trc\fR.
.IP "\fB\-\-sshloginfile\fR \fIfilename\fR" 9
.IX Item "--sshloginfile filename"
.PD 0
.IP "\fB\-\-slf\fR \fIfilename\fR" 9
.IX Item "--slf filename"
.PD
File with sshlogins. The file consists of sshlogins on separate
lines. Empty lines and lines starting with '#' are ignored. Example:
.Sp
.Vb 10
\&  server.example.com
\&  username@server2.example.com
\&  8/my\-8\-core\-server.example.com
\&  2/my_other_username@my\-dualcore.example.net
\&  # This server has SSH running on port 2222
\&  ssh \-p 2222 server.example.net
\&  4/ssh \-p 2222 quadserver.example.net
\&  # Use a different ssh program
\&  myssh \-p 2222 \-l myusername hexacpu.example.net
\&  # Use a different ssh program with default number of cores
\&  //usr/local/bin/myssh \-p 2222 \-l myusername hexacpu
\&  # Use a different ssh program with 6 cores
\&  6//usr/local/bin/myssh \-p 2222 \-l myusername hexacpu
\&  # Assume 16 cores on the local computer
\&  16/:
\&  # Put server1 in hostgroup1
\&  @hostgroup1/server1
\&  # Put myusername@server2 in hostgroup1+hostgroup2
\&  @hostgroup1+hostgroup2/myusername@server2
\&  # Force 4 cores and put \*(Aqssh \-p 2222 server3\*(Aq in hostgroup1
\&  @hostgroup1/4/ssh \-p 2222 server3
.Ve
.Sp
When using a different ssh program the last argument must be the hostname.
.Sp
Multiple \fB\-\-sshloginfile\fR are allowed.
.Sp
\&\s-1GNU \s0\fBparallel\fR will first look for the file in current dir; if that
fails it look for the file in ~/.parallel.
.Sp
The sshloginfile '..' is special, it read sshlogins from
~/.parallel/sshloginfile
.Sp
The sshloginfile '.' is special, it read sshlogins from
/etc/parallel/sshloginfile
.Sp
The sshloginfile '\-' is special, too, it read sshlogins from stdin
(standard input).
.Sp
If the sshloginfile is changed it will be re-read when a job finishes
though at most once per second. This makes it possible to add and
remove hosts while running.
.Sp
This can be used to have a daemon that updates the sshloginfile to
only contain servers that are up:
.Sp
.Vb 10
\&    cp original.slf tmp2.slf
\&    while [ 1 ] ; do
\&      nice parallel \-\-nonall \-j0 \-k \-\-slf original.slf \e
\&        \-\-tag echo | perl \*(Aqs/\et$//\*(Aq > tmp.slf
\&      if diff tmp.slf tmp2.slf; then
\&        mv tmp.slf tmp2.slf
\&      fi
\&      sleep 10
\&    done &
\&    parallel \-\-slf tmp2.slf ...
.Ve
.IP "\fB\-\-slotreplace\fR \fIreplace-str\fR" 9
.IX Item "--slotreplace replace-str"
Use the replacement string \fIreplace-str\fR instead of \fB{%}\fR for
job slot number.
.IP "\fB\-\-silent\fR" 9
.IX Item "--silent"
Silent.  The job to be run will not be printed. This is the default.
Can be reversed with \fB\-v\fR.
.IP "\fB\-\-tty\fR" 9
.IX Item "--tty"
Open terminal tty. If \s-1GNU \s0\fBparallel\fR is used for starting an
interactive program then this option may be needed. It will start only
one job at a time (i.e. \fB\-j1\fR), not buffer the output (i.e. \fB\-u\fR),
and it will open a tty for the job. When the job is done, the next job
will get the tty.
.IP "\fB\-\-tag\fR" 9
.IX Item "--tag"
Tag lines with arguments. Each output line will be prepended with the
arguments and \s-1TAB \s0(\et). When combined with \fB\-\-onall\fR or \fB\-\-nonall\fR
the lines will be prepended with the sshlogin instead.
.Sp
\&\fB\-\-tag\fR is ignored when using \fB\-u\fR.
.IP "\fB\-\-tagstring\fR \fIstr\fR (alpha testing)" 9
.IX Item "--tagstring str (alpha testing)"
Tag lines with a string. Each output line will be prepended with
\&\fIstr\fR and \s-1TAB \s0(\et). \fIstr\fR can contain replacement strings such as
{}.
.Sp
\&\fB\-\-tagstring\fR is ignored when using \fB\-u\fR, \fB\-\-onall\fR, and \fB\-\-nonall\fR.
.IP "\fB\-\-tmpdir\fR \fIdirname\fR" 9
.IX Item "--tmpdir dirname"
Directory for temporary files. \s-1GNU \s0\fBparallel\fR normally buffers output
into temporary files in /tmp. By setting \fB\-\-tmpdir\fR you can use a
different dir for the files. Setting \fB\-\-tmpdir\fR is equivalent to
setting \f(CW$TMPDIR\fR.
.IP "\fB\-\-tmux\fR (alpha testing)" 9
.IX Item "--tmux (alpha testing)"
Use \fBtmux\fR for output. Start a \fBtmux\fR session and run each job in a
window in that session. No other output will be produced.
.IP "\fB\-\-timeout\fR \fIval\fR" 9
.IX Item "--timeout val"
Time out for command. If the command runs for longer than \fIval\fR
seconds it will get killed with \s-1SIGTERM,\s0 followed by \s-1SIGTERM 200\s0 ms
later, followed by \s-1SIGKILL 200\s0 ms later.
.Sp
If \fIval\fR is followed by a % then the timeout will dynamically be
computed as a percentage of the median average runtime. Only values
> 100% will make sense.
.IP "\fB\-\-verbose\fR" 9
.IX Item "--verbose"
.PD 0
.IP "\fB\-t\fR" 9
.IX Item "-t"
.PD
Print the job to be run on stderr (standard error).
.Sp
See also \fB\-v\fR, \fB\-p\fR.
.IP "\fB\-\-transfer\fR (beta testing)" 9
.IX Item "--transfer (beta testing)"
Transfer files to remote computers. \fB\-\-transfer\fR is used with
\&\fB\-\-sshlogin\fR when the arguments are files and should be transferred
to the remote computers. The files will be transferred using \fBrsync\fR
and will be put relative to the default work dir. If the path contains
/./ the remaining path will be relative to the work dir. E.g.
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer wc
.Ve
.Sp
This will transfer the file \fIfoo/bar.txt\fR to the computer
\&\fIserver.example.com\fR to the file \fI\f(CI$HOME\fI/foo/bar.txt\fR before running
\&\fBwc foo/bar.txt\fR on \fIserver.example.com\fR.
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer wc
.Ve
.Sp
This will transfer the file \fIfoo/bar.txt\fR to the computer
\&\fIserver.example.com\fR to the file \fI/tmp/foo/bar.txt\fR before running
\&\fBwc /tmp/foo/bar.txt\fR on \fIserver.example.com\fR.
.Sp
\&\fB\-\-transfer\fR is often used with \fB\-\-return\fR and \fB\-\-cleanup\fR.
.Sp
\&\fB\-\-transfer\fR is ignored when used with \fB\-\-sshlogin :\fR or when not used with \fB\-\-sshlogin\fR.
.IP "\fB\-\-trc\fR \fIfilename\fR (beta testing)" 9
.IX Item "--trc filename (beta testing)"
Transfer, Return, Cleanup. Short hand for:
.Sp
\&\fB\-\-transfer\fR \fB\-\-return\fR \fIfilename\fR \fB\-\-cleanup\fR
.IP "\fB\-\-trim\fR <n|l|r|lr|rl>" 9
.IX Item "--trim <n|l|r|lr|rl>"
Trim white space in input.
.RS 9
.IP "n" 4
.IX Item "n"
No trim. Input is not modified. This is the default.
.IP "l" 4
.IX Item "l"
Left trim. Remove white space from start of input. E.g. \*(L" a bc \*(R" \-> \*(L"a bc \*(R".
.IP "r" 4
.IX Item "r"
Right trim. Remove white space from end of input. E.g. \*(L" a bc \*(R" \-> \*(L" a bc\*(R".
.IP "lr" 4
.IX Item "lr"
.PD 0
.IP "rl" 4
.IX Item "rl"
.PD
Both trim. Remove white space from both start and end of input. E.g. \*(L"
a bc \*(R" \-> \*(L"a bc\*(R". This is the default if \fB\-\-colsep\fR is used.
.RE
.RS 9
.RE
.IP "\fB\-\-ungroup\fR" 9
.IX Item "--ungroup"
.PD 0
.IP "\fB\-u\fR" 9
.IX Item "-u"
.PD
Ungroup output.  Output is printed as soon as possible and by passes
\&\s-1GNU \s0\fBparallel\fR internal processing. This may cause output from
different commands to be mixed thus should only be used if you do not
care about the output. Compare these:
.Sp
.Vb 4
\&  seq 4 | parallel \-j0 \e
\&    \*(Aqsleep {};echo \-n start{};sleep {};echo {}end\*(Aq
\&  seq 4 | parallel \-u \-j0 \e
\&    \*(Aqsleep {};echo \-n start{};sleep {};echo {}end\*(Aq
.Ve
.Sp
It also disables \fB\-\-tag\fR. \s-1GNU \s0\fBparallel\fR outputs faster with
\&\fB\-u\fR. Compare the speed of these:
.Sp
.Vb 3
\&  parallel seq ::: 300000000 >/dev/null
\&  parallel \-u seq ::: 300000000 >/dev/null
\&  parallel \-\-line\-buffer seq ::: 300000000 >/dev/null
.Ve
.Sp
Can be reversed with \fB\-\-group\fR.
.Sp
See also: \fB\-\-line\-buffer\fR \fB\-\-group\fR
.IP "\fB\-\-extensionreplace\fR \fIreplace-str\fR" 9
.IX Item "--extensionreplace replace-str"
.PD 0
.IP "\fB\-\-er\fR \fIreplace-str\fR" 9
.IX Item "--er replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of {.} for input line without extension.
.IP "\fB\-\-use\-cpus\-instead\-of\-cores\fR" 9
.IX Item "--use-cpus-instead-of-cores"
Count the number of physical CPUs instead of \s-1CPU\s0 cores. When computing
how many jobs to run simultaneously relative to the number of \s-1CPU\s0 cores
you can ask \s-1GNU \s0\fBparallel\fR to instead look at the number of physical
CPUs. This will make sense for computers that have hyperthreading as
two jobs running on one \s-1CPU\s0 with hyperthreading will run slower than
two jobs running on two physical CPUs. Some multi-core CPUs can run
faster if only one thread is running per physical \s-1CPU.\s0 Most users will
not need this option.
.IP "\fB\-v\fR" 9
.IX Item "-v"
Verbose.  Print the job to be run on stdout (standard output). Can be reversed
with \fB\-\-silent\fR. See also \fB\-t\fR.
.Sp
Use \fB\-v\fR \fB\-v\fR to print the wrapping ssh command when running remotely.
.IP "\fB\-\-version\fR" 9
.IX Item "--version"
.PD 0
.IP "\fB\-V\fR" 9
.IX Item "-V"
.PD
Print the version \s-1GNU \s0\fBparallel\fR and exit.
.IP "\fB\-\-workdir\fR \fImydir\fR" 9
.IX Item "--workdir mydir"
.PD 0
.IP "\fB\-\-wd\fR \fImydir\fR" 9
.IX Item "--wd mydir"
.PD
Files transferred using \fB\-\-transfer\fR and \fB\-\-return\fR will be relative
to \fImydir\fR on remote computers, and the command will be executed in
the dir \fImydir\fR.
.Sp
The special \fImydir\fR value \fB...\fR will create working dirs under
\&\fB~/.parallel/tmp/\fR on the remote computers. If \fB\-\-cleanup\fR is given
these dirs will be removed.
.Sp
The special \fImydir\fR value \fB.\fR uses the current working dir.  If the
current working dir is beneath your home dir, the value \fB.\fR is
treated as the relative path to your home dir. This means that if your
home dir is different on remote computers (e.g. if your login is
different) the relative path will still be relative to your home dir.
.Sp
To see the difference try:
.Sp
.Vb 3
\&  parallel \-S server pwd ::: ""
\&  parallel \-\-wd . \-S server pwd ::: ""
\&  parallel \-\-wd ... \-S server pwd ::: ""
.Ve
.IP "\fB\-\-wait\fR" 9
.IX Item "--wait"
Wait for all commands to complete.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also \fBman sem\fR.
.IP "\fB\-X\fR" 9
.IX Item "-X"
Multiple arguments with context replace. Insert as many arguments as
the command line length permits. If multiple jobs are being run in
parallel: distribute the arguments evenly among the jobs. Use \fB\-j1\fR
to avoid this.
.Sp
If \fB{}\fR is not used the arguments will be appended to the line.  If
\&\fB{}\fR is used as part of a word (like \fIpic{}.jpg\fR) then the whole
word will be repeated. If \fB{}\fR is used multiple times each \fB{}\fR will
be replaced with the arguments.
.Sp
Normally \fB\-X\fR will do the right thing, whereas \fB\-m\fR can give
unexpected results if \fB{}\fR is used as part of a word.
.Sp
Support for \fB\-X\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
See also \fB\-m\fR.
.IP "\fB\-\-exit\fR" 9
.IX Item "--exit"
.PD 0
.IP "\fB\-x\fR" 9
.IX Item "-x"
.PD
Exit if the size (see the \fB\-s\fR option) is exceeded.
.IP "\fB\-\-xapply\fR" 9
.IX Item "--xapply"
Read multiple input sources like \fBxapply\fR. If multiple input sources
are given, one argument will be read from each of the input
sources. The arguments can be accessed in the command as \fB{1}\fR
\&.. \fB{\fR\fIn\fR\fB}\fR, so \fB{1}\fR will be a line from the first input source, and
\&\fB{6}\fR will refer to the line with the same line number from the 6th
input source.
.Sp
Compare these two:
.Sp
.Vb 2
\&  parallel echo {1} {2} ::: 1 2 3 ::: a b c
\&  parallel \-\-xapply echo {1} {2} ::: 1 2 3 ::: a b c
.Ve
.Sp
Arguments will be recycled if one input source has more arguments than the others:
.Sp
.Vb 2
\&  parallel \-\-xapply echo {1} {2} {3} \e
\&    ::: 1 2 ::: I II III ::: a b c d e f g
.Ve
.Sp
See also \fB\-\-header\fR.
.SH "EXAMPLE: Working as xargs \-n1. Argument appending"
.IX Header "EXAMPLE: Working as xargs -n1. Argument appending"
\&\s-1GNU \s0\fBparallel\fR can work similar to \fBxargs \-n1\fR.
.PP
To compress all html files using \fBgzip\fR run:
.PP
.Vb 1
\&  find . \-name \*(Aq*.html\*(Aq | parallel gzip \-\-best
.Ve
.PP
If the file names may contain a newline use \fB\-0\fR. Substitute \s-1FOO BAR\s0 with
\&\s-1FUBAR\s0 in all files in this dir and subdirs:
.PP
.Vb 1
\&  find . \-type f \-print0 | parallel \-q0 perl \-i \-pe \*(Aqs/FOO BAR/FUBAR/g\*(Aq
.Ve
.PP
Note \fB\-q\fR is needed because of the space in '\s-1FOO BAR\s0'.
.SH "EXAMPLE: Reading arguments from command line"
.IX Header "EXAMPLE: Reading arguments from command line"
\&\s-1GNU \s0\fBparallel\fR can take the arguments from command line instead of
stdin (standard input). To compress all html files in the current dir
using \fBgzip\fR run:
.PP
.Vb 1
\&  parallel gzip \-\-best ::: *.html
.Ve
.PP
To convert *.wav to *.mp3 using \s-1LAME\s0 running one process per \s-1CPU\s0 core
run:
.PP
.Vb 1
\&  parallel lame {} \-o {.}.mp3 ::: *.wav
.Ve
.SH "EXAMPLE: Inserting multiple arguments"
.IX Header "EXAMPLE: Inserting multiple arguments"
When moving a lot of files like this: \fBmv *.log destdir\fR you will
sometimes get the error:
.PP
.Vb 1
\&  bash: /bin/mv: Argument list too long
.Ve
.PP
because there are too many files. You can instead do:
.PP
.Vb 1
\&  ls | grep \-E \*(Aq\e.log$\*(Aq | parallel mv {} destdir
.Ve
.PP
This will run \fBmv\fR for each file. It can be done faster if \fBmv\fR gets
as many arguments that will fit on the line:
.PP
.Vb 1
\&  ls | grep \-E \*(Aq\e.log$\*(Aq | parallel \-m mv {} destdir
.Ve
.SH "EXAMPLE: Context replace"
.IX Header "EXAMPLE: Context replace"
To remove the files \fIpict0000.jpg\fR .. \fIpict9999.jpg\fR you could do:
.PP
.Vb 1
\&  seq \-w 0 9999 | parallel rm pict{}.jpg
.Ve
.PP
You could also do:
.PP
.Vb 1
\&  seq \-w 0 9999 | perl \-pe \*(Aqs/(.*)/pict$1.jpg/\*(Aq | parallel \-m rm
.Ve
.PP
The first will run \fBrm\fR 10000 times, while the last will only run
\&\fBrm\fR as many times needed to keep the command line length short
enough to avoid \fBArgument list too long\fR (it typically runs 1\-2 times).
.PP
You could also run:
.PP
.Vb 1
\&  seq \-w 0 9999 | parallel \-X rm pict{}.jpg
.Ve
.PP
This will also only run \fBrm\fR as many times needed to keep the command
line length short enough.
.SH "EXAMPLE: Compute intensive jobs and substitution"
.IX Header "EXAMPLE: Compute intensive jobs and substitution"
If ImageMagick is installed this will generate a thumbnail of a jpg
file:
.PP
.Vb 1
\&  convert \-geometry 120 foo.jpg thumb_foo.jpg
.Ve
.PP
This will run with number-of-cpu-cores jobs in parallel for all jpg
files in a directory:
.PP
.Vb 1
\&  ls *.jpg | parallel convert \-geometry 120 {} thumb_{}
.Ve
.PP
To do it recursively use \fBfind\fR:
.PP
.Vb 1
\&  find . \-name \*(Aq*.jpg\*(Aq | parallel convert \-geometry 120 {} {}_thumb.jpg
.Ve
.PP
Notice how the argument has to start with \fB{}\fR as \fB{}\fR will include path
(e.g. running \fBconvert \-geometry 120 ./foo/bar.jpg
thumb_./foo/bar.jpg\fR would clearly be wrong). The command will
generate files like ./foo/bar.jpg_thumb.jpg.
.PP
Use \fB{.}\fR to avoid the extra .jpg in the file name. This command will
make files like ./foo/bar_thumb.jpg:
.PP
.Vb 1
\&  find . \-name \*(Aq*.jpg\*(Aq | parallel convert \-geometry 120 {} {.}_thumb.jpg
.Ve
.SH "EXAMPLE: Substitution and redirection"
.IX Header "EXAMPLE: Substitution and redirection"
This will generate an uncompressed version of .gz\-files next to the .gz\-file:
.PP
.Vb 1
\&  parallel zcat {} ">"{.} ::: *.gz
.Ve
.PP
Quoting of > is necessary to postpone the redirection. Another
solution is to quote the whole command:
.PP
.Vb 1
\&  parallel "zcat {} >{.}" ::: *.gz
.Ve
.PP
Other special shell characters (such as * ; $ > < | >> <<) also need
to be put in quotes, as they may otherwise be interpreted by the shell
and not given to \s-1GNU \s0\fBparallel\fR.
.SH "EXAMPLE: Composed commands"
.IX Header "EXAMPLE: Composed commands"
A job can consist of several commands. This will print the number of
files in each directory:
.PP
.Vb 1
\&  ls | parallel \*(Aqecho \-n {}" "; ls {}|wc \-l\*(Aq
.Ve
.PP
To put the output in a file called <name>.dir:
.PP
.Vb 1
\&  ls | parallel \*(Aq(echo \-n {}" "; ls {}|wc \-l) >{}.dir\*(Aq
.Ve
.PP
Even small shell scripts can be run by \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 3
\&  find . | parallel \*(Aqa={}; name=${a##*/};\*(Aq \e
\&    \*(Aqupper=$(echo "$name" | tr "[:lower:]" "[:upper:]");\*(Aq\e
\&    \*(Aqecho "$name \- $upper"\*(Aq
\&
\&  ls | parallel \*(Aqmv {} "$(echo {} | tr "[:upper:]" "[:lower:]")"\*(Aq
.Ve
.PP
Given a list of URLs, list all URLs that fail to download. Print the
line number and the \s-1URL.\s0
.PP
.Vb 1
\&  cat urlfile | parallel "wget {} 2>/dev/null || grep \-n {} urlfile"
.Ve
.PP
Create a mirror directory with the same filenames except all files and
symlinks are empty files.
.PP
.Vb 2
\&  cp \-rs /the/source/dir mirror_dir
\&  find mirror_dir \-type l | parallel \-m rm {} \*(Aq&&\*(Aq touch {}
.Ve
.PP
Find the files in a list that do not exist
.PP
.Vb 1
\&  cat file_list | parallel \*(Aqif [ ! \-e {} ] ; then echo {}; fi\*(Aq
.Ve
.SH "EXAMPLE: Calling Bash functions"
.IX Header "EXAMPLE: Calling Bash functions"
If the composed command is longer than a line, it becomes hard to
read. In Bash you can use functions. Just remember to \fBexport \-f\fR the
function.
.PP
.Vb 7
\&  doit() {
\&    echo Doing it for $1
\&    sleep 2
\&    echo Done with $1
\&  }
\&  export \-f doit
\&  parallel doit ::: 1 2 3
\&
\&  doubleit() {
\&    echo Doing it for $1 $2
\&    sleep 2
\&    echo Done with $1 $2
\&  }
\&  export \-f doubleit
\&  parallel doubleit ::: 1 2 3 ::: a b
.Ve
.PP
To do this on remote servers you need to transfer the function using
\&\fB\-\-env\fR:
.PP
.Vb 2
\&  parallel \-\-env doit \-S server doit ::: 1 2 3
\&  parallel \-\-env doubleit \-S server doubleit ::: 1 2 3 ::: a b
.Ve
.PP
If your environment (aliases, variables, and functions) is small you
can copy the full environment without having to \fBexport \-f\fR
anything. Just run this first:
.PP
.Vb 8
\&  env_parallel() {
\&      export parallel_bash_environment=\*(Aq() {
\&        \*(Aq"$(echo "shopt \-s expand_aliases 2>/dev/null"; alias;typeset \-p | grep \-vFf <(readonly; echo GROUPS; echo FUNCNAME; echo DIRSTACK; echo _; echo PIPESTATUS; echo USERNAME) | grep \-v BASH_;typeset \-f)"\*(Aq
\&      }\*(Aq
\&      # Run as: env_parallel parallel_bash_environment "2>/dev/null;" ...
\&      \`which parallel\` "$@"
\&      unset parallel_bash_environment
\&  }
.Ve
.PP
And then call as:
.PP
.Vb 4
\&  env_parallel doit ::: 1 2 3
\&  env_parallel doubleit ::: 1 2 3 ::: a b
\&  env_parallel \-S server doit ::: 1 2 3
\&  env_parallel \-S server doubleit ::: 1 2 3 ::: a b
.Ve
.SH "EXAMPLE: Function tester"
.IX Header "EXAMPLE: Function tester"
To test a program with different parameters:
.PP
.Vb 10
\&  tester() {
\&    if (eval "$@") >&/dev/null; then
\&      perl \-e \*(Aqprintf "\e033[30;102m[ OK ]\e033[0m @ARGV\en"\*(Aq "$@"
\&    else
\&      perl \-e \*(Aqprintf "\e033[30;101m[FAIL]\e033[0m @ARGV\en"\*(Aq "$@"
\&    fi
\&  }
\&  export \-f tester
\&  parallel tester my_program ::: arg1 arg2
\&  parallel tester exit ::: 1 0 2 0
.Ve
.PP
If \fBmy_program\fR fails a red \s-1FAIL\s0 will be printed followed by the failing
command; otherwise a green \s-1OK\s0 will be printed followed by the command.
.SH "EXAMPLE: Removing file extension when processing files"
.IX Header "EXAMPLE: Removing file extension when processing files"
When processing files removing the file extension using \fB{.}\fR is
often useful.
.PP
Create a directory for each zip-file and unzip it in that dir:
.PP
.Vb 1
\&  parallel \*(Aqmkdir {.}; cd {.}; unzip ../{}\*(Aq ::: *.zip
.Ve
.PP
Recompress all .gz files in current directory using \fBbzip2\fR running 1
job per \s-1CPU\s0 core in parallel:
.PP
.Vb 1
\&  parallel "zcat {} | bzip2 >{.}.bz2 && rm {}" ::: *.gz
.Ve
.PP
Convert all \s-1WAV\s0 files to \s-1MP3\s0 using \s-1LAME:\s0
.PP
.Vb 1
\&  find sounddir \-type f \-name \*(Aq*.wav\*(Aq | parallel lame {} \-o {.}.mp3
.Ve
.PP
Put all converted in the same directory:
.PP
.Vb 2
\&  find sounddir \-type f \-name \*(Aq*.wav\*(Aq | \e
\&    parallel lame {} \-o mydir/{/.}.mp3
.Ve
.SH "EXAMPLE: Removing two file extensions when processing files"
.IX Header "EXAMPLE: Removing two file extensions when processing files"
If you have directory with tar.gz files and want these extracted in
the corresponding dir (e.g foo.tar.gz will be extracted in the dir
foo) you can do:
.PP
.Vb 1
\&  parallel \-\-plus \*(Aqmkdir {..}; tar \-C {..} \-xf {}\*(Aq ::: *.tar.gz
.Ve
.SH "EXAMPLE: Download 10 images for each of the past 30 days"
.IX Header "EXAMPLE: Download 10 images for each of the past 30 days"
Let us assume a website stores images like:
.PP
.Vb 1
\&  http://www.example.com/path/to/YYYYMMDD_##.jpg
.Ve
.PP
where \s-1YYYYMMDD\s0 is the date and ## is the number 01\-10. This will
download images for the past 30 days:
.PP
.Vb 1
\&  parallel wget http://www.example.com/path/to/\*(Aq$(date \-d "today \-{1} days" +%Y%m%d)_{2}.jpg\*(Aq ::: $(seq 30) ::: $(seq \-w 10)
.Ve
.PP
\&\fB$(date \-d \*(L"today \-{1} days\*(R" +%Y%m%d)\fR will give the dates in
\&\s-1YYYYMMDD\s0 with {1} days subtracted.
.SH "EXAMPLE: Copy files as last modified date (ISO8601) with added random digits"
.IX Header "EXAMPLE: Copy files as last modified date (ISO8601) with added random digits"
.Vb 2
\&  find . | parallel cp {} \e
\&    \*(Aq../destdir/{= $a=int(10000*rand); $_=\`date \-r "$_" +%FT%T"$a"\`; chomp; =}\*(Aq
.Ve
.PP
\&\fB{=\fR and \fB=}\fR mark a perl expression. \fBdate +%FT%T\fR is the date in \s-1ISO8601\s0 with time.
.ie n .SH "EXAMPLE: Digtal clock with ""blinking"" :"
.el .SH "EXAMPLE: Digtal clock with ``blinking'' :"
.IX Header "EXAMPLE: Digtal clock with blinking :"
The : in a digital clock blinks. To make every other line have a ':'
and the rest a ' ' a perl expression is used to look at the 3rd input
source. If the value modudo 2 is 1: Use \*(L":\*(R" otherwise use \*(L" \*(R":
.PP
.Vb 2
\&  parallel \-k echo {1}\*(Aq{=3 $_=$_%2?":":" "=}\*(Aq{2}{3} \e
\&    ::: {0..12} ::: {0..5} ::: {0..9}
.Ve
.SH "EXAMPLE: Aggregating content of files"
.IX Header "EXAMPLE: Aggregating content of files"
This:
.PP
.Vb 2
\&  parallel \-\-header : echo x{X}y{Y}z{Z} \e> x{X}y{Y}z{Z} \e
\&  ::: X {1..5} ::: Y {01..10} ::: Z {1..5}
.Ve
.PP
will generate the files x1y01z1 .. x5y10z5. If you want to aggregate
the output grouping on x and z you can do this:
.PP
.Vb 1
\&  parallel eval \*(Aqcat {=s/y01/y*/=} > {=s/y01//=}\*(Aq ::: *y01*
.Ve
.PP
For all values of x and z it runs commands like:
.PP
.Vb 1
\&  cat x1y*z1 > x1z1
.Ve
.PP
So you end up with x1z1 .. x1z5 each containing the content of all
values of y.
.SH "EXAMPLE: Breadth first parallel web crawler/mirrorer"
.IX Header "EXAMPLE: Breadth first parallel web crawler/mirrorer"
This script below will crawl and mirror a \s-1URL\s0 in parallel.  It
downloads first pages that are 1 click down, then 2 clicks down, then
3; instead of the normal depth first, where the first link link on
each page is fetched first.
.PP
Run like this:
.PP
.Vb 1
\&  PARALLEL=\-j100 ./parallel\-crawl http://gatt.org.yeslab.org/
.Ve
.PP
Remove the \fBwget\fR part if you only want a web crawler.
.PP
It works by fetching a page from a list of URLs and looking for links
in that page that are within the same starting \s-1URL\s0 and that have not
already been seen. These links are added to a new queue. When all the
pages from the list is done, the new queue is moved to the list of
URLs and the process is started over until no unseen links are found.
.PP
.Vb 1
\&  #!/bin/bash
\&
\&  # E.g. http://gatt.org.yeslab.org/
\&  URL=$1
\&  # Stay inside the start dir
\&  BASEURL=$(echo $URL | perl \-pe \*(Aqs:#.*::; s:(//.*/)[^/]*:$1:\*(Aq)
\&  URLLIST=$(mktemp urllist.XXXX)
\&  URLLIST2=$(mktemp urllist.XXXX)
\&  SEEN=$(mktemp seen.XXXX)
\&
\&  # Spider to get the URLs
\&  echo $URL >$URLLIST
\&  cp $URLLIST $SEEN
\&
\&  while [ \-s $URLLIST ] ; do
\&    cat $URLLIST |
\&      parallel lynx \-listonly \-image_links \-dump {} \e; \e
\&        wget \-qm \-l1 \-Q1 {} \e; echo Spidered: {} \e>\e&2 |
\&        perl \-ne \*(Aqs/#.*//; s/\es+\ed+.\es(\eS+)$/$1/ and do { $seen{$1}++ or print }\*(Aq |
\&      grep \-F $BASEURL |
\&      grep \-v \-x \-F \-f $SEEN | tee \-a $SEEN > $URLLIST2
\&    mv $URLLIST2 $URLLIST
\&  done
\&
\&  rm \-f $URLLIST $URLLIST2 $SEEN
.Ve
.SH "EXAMPLE: Process files from a tar file while unpacking"
.IX Header "EXAMPLE: Process files from a tar file while unpacking"
If the files to be processed are in a tar file then unpacking one file
and processing it immediately may be faster than first unpacking all
files.
.PP
.Vb 2
\&  tar xvf foo.tgz | perl \-ne \*(Aqprint $l;$l=$_;END{print $l}\*(Aq | \e
\&    parallel echo
.Ve
.PP
The Perl one-liner is needed to avoid race condition.
.SH "EXAMPLE: Rewriting a for-loop and a while-read-loop"
.IX Header "EXAMPLE: Rewriting a for-loop and a while-read-loop"
for-loops like this:
.PP
.Vb 3
\&  (for x in \`cat list\` ; do
\&    do_something $x
\&  done) | process_output
.Ve
.PP
and while-read-loops like this:
.PP
.Vb 3
\&  cat list | (while read x ; do
\&    do_something $x
\&  done) | process_output
.Ve
.PP
can be written like this:
.PP
.Vb 1
\&  cat list | parallel do_something | process_output
.Ve
.PP
For example: Find which host name in a list has \s-1IP\s0 address 1.2.3 4:
.PP
.Vb 1
\&  cat hosts.txt | parallel \-P 100 host | grep 1.2.3.4
.Ve
.PP
If the processing requires more steps the for-loop like this:
.PP
.Vb 5
\&  (for x in \`cat list\` ; do
\&    no_extension=${x%.*};
\&    do_something $x scale $no_extension.jpg
\&    do_step2 <$x $no_extension
\&  done) | process_output
.Ve
.PP
and while-loops like this:
.PP
.Vb 5
\&  cat list | (while read x ; do
\&    no_extension=${x%.*};
\&    do_something $x scale $no_extension.jpg
\&    do_step2 <$x $no_extension
\&  done) | process_output
.Ve
.PP
can be written like this:
.PP
.Vb 2
\&  cat list | parallel "do_something {} scale {.}.jpg ; do_step2 <{} {.}" |\e
\&    process_output
.Ve
.PP
If the body of the loop is bigger, it improves readability to use a function:
.PP
.Vb 4
\&  (for x in \`cat list\` ; do
\&    do_something $x
\&    [... 100 lines that do something with $x ...]
\&  done) | process_output
\&
\&  cat list | (while read x ; do
\&    do_something $x
\&    [... 100 lines that do something with $x ...]
\&  done) | process_output
.Ve
.PP
can both be rewritten as:
.PP
.Vb 7
\&  doit() {
\&    x=$1
\&    do_something $x
\&    [... 100 lines that do something with $x ...]
\&  }
\&  export \-f doit
\&  cat list | parallel doit
.Ve
.SH "EXAMPLE: Rewriting nested for-loops"
.IX Header "EXAMPLE: Rewriting nested for-loops"
Nested for-loops like this:
.PP
.Vb 5
\&  (for x in \`cat xlist\` ; do
\&    for y in \`cat ylist\` ; do
\&      do_something $x $y
\&    done
\&  done) | process_output
.Ve
.PP
can be written like this:
.PP
.Vb 1
\&  parallel do_something {1} {2} :::: xlist ylist | process_output
.Ve
.PP
Nested for-loops like this:
.PP
.Vb 5
\&  (for gender in M F ; do
\&    for size in S M L XL XXL ; do
\&      echo $gender $size
\&    done
\&  done) | sort
.Ve
.PP
can be written like this:
.PP
.Vb 1
\&  parallel echo {1} {2} ::: M F ::: S M L XL XXL | sort
.Ve
.SH "EXAMPLE: Finding the lowest difference between files"
.IX Header "EXAMPLE: Finding the lowest difference between files"
\&\fBdiff\fR is good for finding differences in text files. \fBdiff | wc \-l\fR
gives an indication of the size of the difference. To find the
differences between all files in the current dir do:
.PP
.Vb 1
\&  parallel \-\-tag \*(Aqdiff {1} {2} | wc \-l\*(Aq ::: * ::: * | sort \-nk3
.Ve
.PP
This way it is possible to see if some files are closer to other
files.
.SH "EXAMPLE: for-loops with column names"
.IX Header "EXAMPLE: for-loops with column names"
When doing multiple nested for-loops it can be easier to keep track of
the loop variable if is is named instead of just having a number. Use
\&\fB\-\-header :\fR to let the first argument be an named alias for the
positional replacement string:
.PP
.Vb 1
\&  parallel \-\-header : echo {gender} {size} ::: gender M F ::: size S M L XL
.Ve
.PP
This also works if the input file is a file with columns:
.PP
.Vb 2
\&  cat addressbook.tsv | \e
\&    parallel \-\-colsep \*(Aq\et\*(Aq \-\-header : echo {Name} {E\-mail address}
.Ve
.SH "EXAMPLE: Count the differences between all files in a dir"
.IX Header "EXAMPLE: Count the differences between all files in a dir"
Using \fB\-\-results\fR the results are saved in /tmp/diffcount*.
.PP
.Vb 2
\&  parallel \-\-results /tmp/diffcount "diff \-U 0 {1} {2} | \e
\&    tail \-n +3 |grep \-v \*(Aq^@\*(Aq|wc \-l" ::: * ::: *
.Ve
.PP
To see the difference between file A and file B look at the file
\&'/tmp/diffcount/1/A/2/B'.
.SH "EXAMPLE: Speeding up fast jobs"
.IX Header "EXAMPLE: Speeding up fast jobs"
Starting a job on the local machine takes around 10 ms. This can be a
big overhead if the job takes very few ms to run. Often you can group
small jobs together using \fB\-X\fR which will make the overhead less
significant. Compare the speed of these:
.PP
.Vb 2
\&  seq \-w 0 9999 | parallel touch pict{}.jpg
\&  seq \-w 0 9999 | parallel \-X touch pict{}.jpg
.Ve
.PP
If your program cannot take multiple arguments, then you can use \s-1GNU
\&\s0\fBparallel\fR to spawn multiple \s-1GNU \s0\fBparallel\fRs:
.PP
.Vb 1
\&  seq \-w 0 999999 | parallel \-j10 \-\-pipe parallel \-j0 touch pict{}.jpg
.Ve
.PP
If \fB\-j0\fR normally spawns 252 jobs, then the above will try to spawn
2520 jobs. On a normal GNU/Linux system you can spawn 32000 jobs using
this technique with no problems. To raise the 32000 jobs limit raise
/proc/sys/kernel/pid_max to 4194303.
.SH "EXAMPLE: Using shell variables"
.IX Header "EXAMPLE: Using shell variables"
When using shell variables you need to quote them correctly as they
may otherwise be split on spaces.
.PP
Notice the difference between:
.PP
.Vb 2
\&  V=("My brother\*(Aqs 12\e" records are worth <\e$\e$\e$>"\*(Aq!\*(Aq Foo Bar)
\&  parallel echo ::: ${V[@]} # This is probably not what you want
.Ve
.PP
and:
.PP
.Vb 2
\&  V=("My brother\*(Aqs 12\e" records are worth <\e$\e$\e$>"\*(Aq!\*(Aq Foo Bar)
\&  parallel echo ::: "${V[@]}"
.Ve
.PP
When using variables in the actual command that contains special
characters (e.g. space) you can quote them using \fB'\*(L"$VAR\*(R"'\fR or using
"'s and \fB\-q\fR:
.PP
.Vb 3
\&  V="Here  are  two "
\&  parallel echo "\*(Aq$V\*(Aq" ::: spaces
\&  parallel \-q echo "$V" ::: spaces
.Ve
.SH "EXAMPLE: Group output lines"
.IX Header "EXAMPLE: Group output lines"
When running jobs that output data, you often do not want the output
of multiple jobs to run together. \s-1GNU \s0\fBparallel\fR defaults to grouping
the output of each job, so the output is printed when the job
finishes. If you want full lines to be printed while the job is
running you can use \fB\-\-line\-buffer\fR. If you want output to be
printed as soon as possible you can use \fB\-u\fR.
.PP
Compare the output of:
.PP
.Vb 3
\&  parallel traceroute ::: foss.org.my debian.org freenetproject.org
\&  parallel \-\-line\-buffer traceroute ::: foss.org.my debian.org freenetproject.org
\&  parallel \-u traceroute ::: foss.org.my debian.org freenetproject.org
.Ve
.SH "EXAMPLE: Tag output lines"
.IX Header "EXAMPLE: Tag output lines"
\&\s-1GNU \s0\fBparallel\fR groups the output lines, but it can be hard to see
where the different jobs begin. \fB\-\-tag\fR prepends the argument to make
that more visible:
.PP
.Vb 1
\&  parallel \-\-tag traceroute ::: foss.org.my debian.org freenetproject.org
.Ve
.PP
\&\fB\-\-tag\fR works with \fB\-\-line\-buffer\fR but not with \fB\-u\fR:
.PP
.Vb 2
\&  parallel \-\-tag \-\-line\-buffer traceroute \e
\&    ::: foss.org.my debian.org freenetproject.org
.Ve
.PP
Check the uptime of the servers in \fI~/.parallel/sshloginfile\fR:
.PP
.Vb 1
\&  parallel \-\-tag \-S .. \-\-nonall uptime
.Ve
.SH "EXAMPLE: Keep order of output same as order of input"
.IX Header "EXAMPLE: Keep order of output same as order of input"
Normally the output of a job will be printed as soon as it
completes. Sometimes you want the order of the output to remain the
same as the order of the input. This is often important, if the output
is used as input for another system. \fB\-k\fR will make sure the order of
output will be in the same order as input even if later jobs end
before earlier jobs.
.PP
Append a string to every line in a text file:
.PP
.Vb 1
\&  cat textfile | parallel \-k echo {} append_string
.Ve
.PP
If you remove \fB\-k\fR some of the lines may come out in the wrong order.
.PP
Another example is \fBtraceroute\fR:
.PP
.Vb 1
\&  parallel traceroute ::: foss.org.my debian.org freenetproject.org
.Ve
.PP
will give traceroute of foss.org.my, debian.org and
freenetproject.org, but it will be sorted according to which job
completed first.
.PP
To keep the order the same as input run:
.PP
.Vb 1
\&  parallel \-k traceroute ::: foss.org.my debian.org freenetproject.org
.Ve
.PP
This will make sure the traceroute to foss.org.my will be printed
first.
.PP
A bit more complex example is downloading a huge file in chunks in
parallel: Some internet connections will deliver more data if you
download files in parallel. For downloading files in parallel see:
\&\*(L"\s-1EXAMPLE:\s0 Download 10 images for each of the past 30 days\*(R". But if you
are downloading a big file you can download the file in chunks in
parallel.
.PP
To download byte 10000000\-19999999 you can use \fBcurl\fR:
.PP
.Vb 1
\&  curl \-r 10000000\-19999999 http://example.com/the/big/file >file.part
.Ve
.PP
To download a 1 \s-1GB\s0 file we need 100 10MB chunks downloaded and
combined in the correct order.
.PP
.Vb 2
\&  seq 0 99 | parallel \-k curl \-r \e
\&    {}0000000\-{}9999999 http://example.com/the/big/file > file
.Ve
.SH "EXAMPLE: Parallel grep"
.IX Header "EXAMPLE: Parallel grep"
\&\fBgrep \-r\fR greps recursively through directories. On multicore CPUs
\&\s-1GNU \s0\fBparallel\fR can often speed this up.
.PP
.Vb 1
\&  find . \-type f | parallel \-k \-j150% \-n 1000 \-m grep \-H \-n STRING {}
.Ve
.PP
This will run 1.5 job per core, and give 1000 arguments to \fBgrep\fR.
.SH "EXAMPLE: Grepping n lines for m regular expressions."
.IX Header "EXAMPLE: Grepping n lines for m regular expressions."
The simplest solution to grep a big file for a lot of regexps is:
.PP
.Vb 1
\&  grep \-f regexps.txt bigfile
.Ve
.PP
Or if the regexps are fixed strings:
.PP
.Vb 1
\&  grep \-F \-f regexps.txt bigfile
.Ve
.PP
There are 2 limiting factors: \s-1CPU\s0 and disk I/O. \s-1CPU\s0 is easy to
measure: If the grep takes >90% \s-1CPU \s0(e.g. when running top), then the
\&\s-1CPU\s0 is a limiting factor, and parallelization will speed this up. If
not, then disk I/O is the limiting factor, and depending on the disk
system it may be faster or slower to parallelize. The only way to know
for certain is to measure.
.PP
If the \s-1CPU\s0 is the limiting factor parallelization should be done on the regexps:
.PP
.Vb 1
\&  cat regexp.txt | parallel \-\-pipe \-L1000 \-\-round\-robin grep \-f \- bigfile
.Ve
.PP
If a line matches multiple regexps, the line may be duplicated. The command
will start one grep per \s-1CPU\s0 and read bigfile one time per \s-1CPU,\s0
but as that is done in parallel, all reads except the first will be
cached in \s-1RAM.\s0 Depending on the size of regexp.txt it may be faster to
use \-\-block 10m instead of \-L1000. If regexp.txt is too big to fit in
\&\s-1RAM,\s0 remove \-\-round\-robin and adjust \-L1000. This will cause bigfile
to be read more times.
.PP
Some storage systems perform better when reading multiple chunks in
parallel. This is true for some \s-1RAID\s0 systems and for some network file
systems. To parallelize the reading of bigfile:
.PP
.Vb 1
\&  parallel \-\-pipepart \-\-block 100M \-a bigfile \-k grep \-f regexp.txt
.Ve
.PP
This will split bigfile into 100MB chunks and run grep on each of
these chunks. To parallelize both reading of bigfile and regexp.txt
combine the two using \-\-fifo:
.PP
.Vb 2
\&  parallel \-\-pipepart \-\-block 100M \-a bigfile \-\-fifo cat regexp.txt \e
\&    \e| parallel \-\-pipe \-L1000 \-\-round\-robin grep \-f \- {}
.Ve
.PP
If a line matches multiple regexps, the line may be duplicated.
.SH "EXAMPLE: Using remote computers"
.IX Header "EXAMPLE: Using remote computers"
To run commands on a remote computer \s-1SSH\s0 needs to be set up and you
must be able to login without entering a password (The commands
\&\fBssh-copy-id\fR and \fBssh-agent\fR may help you do that).
.PP
If you need to login to a whole cluster, you typically do not want to
accept the host key for every host. You want to accept them the first
time and be warned if they are ever changed. To do that:
.PP
.Vb 10
\&  # Add the servers to the sshloginfile
\&  (echo servera; echo serverb) > .parallel/my_cluster
\&  # Make sure .ssh/config exist
\&  touch .ssh/config
\&  cp .ssh/config .ssh/config.backup
\&  # Disable StrictHostKeyChecking temporarily
\&  (echo \*(AqHost *\*(Aq; echo StrictHostKeyChecking no) >> .ssh/config
\&  parallel \-\-slf my_cluster \-\-nonall true
\&  # Remove the disabling of StrictHostKeyChecking
\&  mv .ssh/config.backup .ssh/config
.Ve
.PP
The servers in \fB.parallel/my_cluster\fR are now added in \fB.ssh/known_hosts\fR.
.PP
To run \fBecho\fR on \fBserver.example.com\fR:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin server.example.com echo
.Ve
.PP
To run commands on more than one remote computer run:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin server.example.com,server2.example.net echo
.Ve
.PP
Or:
.PP
.Vb 2
\&  seq 10 | parallel \-\-sshlogin server.example.com \e
\&    \-\-sshlogin server2.example.net echo
.Ve
.PP
If the login username is \fIfoo\fR on \fIserver2.example.net\fR use:
.PP
.Vb 2
\&  seq 10 | parallel \-\-sshlogin server.example.com \e
\&    \-\-sshlogin foo@server2.example.net echo
.Ve
.PP
If your list of hosts is \fIserver1\-88.example.net\fR with login \fIfoo\fR:
.PP
.Vb 1
\&  seq 10 | parallel \-Sfoo@server{1..88}.example.net echo
.Ve
.PP
To distribute the commands to a list of computers, make a file
\&\fImycomputers\fR with all the computers:
.PP
.Vb 3
\&  server.example.com
\&  foo@server2.example.com
\&  server3.example.com
.Ve
.PP
Then run:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshloginfile mycomputers echo
.Ve
.PP
To include the local computer add the special sshlogin ':' to the list:
.PP
.Vb 4
\&  server.example.com
\&  foo@server2.example.com
\&  server3.example.com
\&  :
.Ve
.PP
\&\s-1GNU \s0\fBparallel\fR will try to determine the number of \s-1CPU\s0 cores on each
of the remote computers, and run one job per \s-1CPU\s0 core \- even if the
remote computers do not have the same number of \s-1CPU\s0 cores.
.PP
If the number of \s-1CPU\s0 cores on the remote computers is not identified
correctly the number of \s-1CPU\s0 cores can be added in front. Here the
computer has 8 \s-1CPU\s0 cores.
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin 8/server.example.com echo
.Ve
.SH "EXAMPLE: Transferring of files"
.IX Header "EXAMPLE: Transferring of files"
To recompress gzipped files with \fBbzip2\fR using a remote computer run:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
This will list the .gz\-files in the \fIlogs\fR directory and all
directories below. Then it will transfer the files to
\&\fIserver.example.com\fR to the corresponding directory in
\&\fI\f(CI$HOME\fI/logs\fR. On \fIserver.example.com\fR the file will be recompressed
using \fBzcat\fR and \fBbzip2\fR resulting in the corresponding file with
\&\fI.gz\fR replaced with \fI.bz2\fR.
.PP
If you want the resulting bz2\-file to be transferred back to the local
computer add \fI\-\-return {.}.bz2\fR:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
After the recompressing is done the \fI.bz2\fR\-file is transferred back to
the local computer and put next to the original \fI.gz\fR\-file.
.PP
If you want to delete the transferred files on the remote computer add
\&\fI\-\-cleanup\fR. This will remove both the file transferred to the remote
computer and the files transferred from the remote computer:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
If you want run on several computers add the computers to \fI\-\-sshlogin\fR
either using ',' or multiple \fI\-\-sshlogin\fR:
.PP
.Vb 4
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
You can add the local computer using \fI\-\-sshlogin :\fR. This will disable the
removing and transferring for the local computer only:
.PP
.Vb 5
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-sshlogin : \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
Often \fI\-\-transfer\fR, \fI\-\-return\fR and \fI\-\-cleanup\fR are used together. They can be
shortened to \fI\-\-trc\fR:
.PP
.Vb 5
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-sshlogin : \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
With the file \fImycomputers\fR containing the list of computers it becomes:
.PP
.Vb 2
\&  find logs/ \-name \*(Aq*.gz\*(Aq | parallel \-\-sshloginfile mycomputers \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
If the file \fI~/.parallel/sshloginfile\fR contains the list of computers
the special short hand \fI\-S ..\fR can be used:
.PP
.Vb 2
\&  find logs/ \-name \*(Aq*.gz\*(Aq | parallel \-S .. \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.SH "EXAMPLE: Distributing work to local and remote computers"
.IX Header "EXAMPLE: Distributing work to local and remote computers"
Convert *.mp3 to *.ogg running one process per \s-1CPU\s0 core on local computer and server2:
.PP
.Vb 2
\&  parallel \-\-trc {.}.ogg \-S server2,: \e
\&    \*(Aqmpg321 \-w \- {} | oggenc \-q0 \- \-o {.}.ogg\*(Aq ::: *.mp3
.Ve
.SH "EXAMPLE: Running the same command on remote computers"
.IX Header "EXAMPLE: Running the same command on remote computers"
To run the command \fBuptime\fR on remote computers you can do:
.PP
.Vb 1
\&  parallel \-\-tag \-\-nonall \-S server1,server2 uptime
.Ve
.PP
\&\fB\-\-nonall\fR reads no arguments. If you have a list of jobs you want
run on each computer you can do:
.PP
.Vb 1
\&  parallel \-\-tag \-\-onall \-S server1,server2 echo ::: 1 2 3
.Ve
.PP
Remove \fB\-\-tag\fR if you do not want the sshlogin added before the
output.
.PP
If you have a lot of hosts use '\-j0' to access more hosts in parallel.
.SH "EXAMPLE: Parallelizing rsync"
.IX Header "EXAMPLE: Parallelizing rsync"
\&\fBrsync\fR is a great tool, but sometimes it will not fill up the
available bandwidth. This is often a problem when copying several big
files over high speed connections.
.PP
The following will start one \fBrsync\fR per big file in \fIsrc-dir\fR to
\&\fIdest-dir\fR on the server \fIfooserver\fR:
.PP
.Vb 3
\&  cd src\-dir; find . \-type f \-size +100000 | \e
\&    parallel \-v ssh fooserver mkdir \-p /dest\-dir/{//}\e; \e
\&      rsync \-s \-Havessh {} fooserver:/dest\-dir/{}
.Ve
.PP
The dirs created may end up with wrong permissions and smaller files
are not being transferred. To fix those run \fBrsync\fR a final time:
.PP
.Vb 1
\&  rsync \-Havessh src\-dir/ fooserver:/dest\-dir/
.Ve
.PP
If you are unable to push data, but need to pull them and the files
are called digits.png (e.g. 000000.png) you might be able to do:
.PP
.Vb 1
\&  seq \-w 0 99 | parallel rsync \-Havessh fooserver:src\-path/*{}.png destdir/
.Ve
.SH "EXAMPLE: Use multiple inputs in one command"
.IX Header "EXAMPLE: Use multiple inputs in one command"
Copy files like foo.es.ext to foo.ext:
.PP
.Vb 1
\&  ls *.es.* | perl \-pe \*(Aqprint; s/\e.es//\*(Aq | parallel \-N2 cp {1} {2}
.Ve
.PP
The perl command spits out 2 lines for each input. \s-1GNU \s0\fBparallel\fR
takes 2 inputs (using \fB\-N2\fR) and replaces {1} and {2} with the inputs.
.PP
Count in binary:
.PP
.Vb 1
\&  parallel \-k echo ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1
.Ve
.PP
Print the number on the opposing sides of a six sided die:
.PP
.Vb 2
\&  parallel \-\-xapply \-a <(seq 6) \-a <(seq 6 \-1 1) echo
\&  parallel \-\-xapply echo :::: <(seq 6) <(seq 6 \-1 1)
.Ve
.PP
Convert files from all subdirs to PNG-files with consecutive numbers
(useful for making input \s-1PNG\s0's for \fBffmpeg\fR):
.PP
.Vb 2
\&  parallel \-\-xapply \-a <(find . \-type f | sort) \e
\&    \-a <(seq $(find . \-type f|wc \-l)) convert {1} {2}.png
.Ve
.PP
Alternative version:
.PP
.Vb 1
\&  find . \-type f | sort | parallel convert {} {#}.png
.Ve
.SH "EXAMPLE: Use a table as input"
.IX Header "EXAMPLE: Use a table as input"
Content of table_file.tsv:
.PP
.Vb 2
\&  foo<TAB>bar
\&  baz <TAB> quux
.Ve
.PP
To run:
.PP
.Vb 2
\&  cmd \-o bar \-i foo
\&  cmd \-o quux \-i baz
.Ve
.PP
you can run:
.PP
.Vb 1
\&  parallel \-a table_file.tsv \-\-colsep \*(Aq\et\*(Aq cmd \-o {2} \-i {1}
.Ve
.PP
Note: The default for \s-1GNU \s0\fBparallel\fR is to remove the spaces around the columns. To keep the spaces:
.PP
.Vb 1
\&  parallel \-a table_file.tsv \-\-trim n \-\-colsep \*(Aq\et\*(Aq cmd \-o {2} \-i {1}
.Ve
.SH "EXAMPLE: Run the same command 10 times"
.IX Header "EXAMPLE: Run the same command 10 times"
If you want to run the same command with the same arguments 10 times
in parallel you can do:
.PP
.Vb 1
\&  seq 10 | parallel \-n0 my_command my_args
.Ve
.SH "EXAMPLE: Working as cat | sh. Resource inexpensive jobs and evaluation"
.IX Header "EXAMPLE: Working as cat | sh. Resource inexpensive jobs and evaluation"
\&\s-1GNU \s0\fBparallel\fR can work similar to \fBcat | sh\fR.
.PP
A resource inexpensive job is a job that takes very little \s-1CPU,\s0 disk
I/O and network I/O. Ping is an example of a resource inexpensive
job. wget is too \- if the webpages are small.
.PP
The content of the file jobs_to_run:
.PP
.Vb 7
\&  ping \-c 1 10.0.0.1
\&  wget http://example.com/status.cgi?ip=10.0.0.1
\&  ping \-c 1 10.0.0.2
\&  wget http://example.com/status.cgi?ip=10.0.0.2
\&  ...
\&  ping \-c 1 10.0.0.255
\&  wget http://example.com/status.cgi?ip=10.0.0.255
.Ve
.PP
To run 100 processes simultaneously do:
.PP
.Vb 1
\&  parallel \-j 100 < jobs_to_run
.Ve
.PP
As there is not a \fIcommand\fR the jobs will be evaluated by the shell.
.SH "EXAMPLE: Processing a big file using more cores"
.IX Header "EXAMPLE: Processing a big file using more cores"
To process a big file or some output you can use \fB\-\-pipe\fR to split up
the data into blocks and pipe the blocks into the processing program.
.PP
If the program is \fBgzip \-9\fR you can do:
.PP
.Vb 1
\&  cat bigfile | parallel \-\-pipe \-\-recend \*(Aq\*(Aq \-k gzip \-9 > bigfile.gz
.Ve
.PP
This will split \fBbigfile\fR into blocks of 1 \s-1MB\s0 and pass that to \fBgzip
\&\-9\fR in parallel. One \fBgzip\fR will be run per \s-1CPU\s0 core. The output of
\&\fBgzip \-9\fR will be kept in order and saved to \fBbigfile.gz\fR
.PP
\&\fBgzip\fR works fine if the output is appended, but some processing does
not work like that \- for example sorting. For this \s-1GNU \s0\fBparallel\fR can
put the output of each command into a file. This will sort a big file
in parallel:
.PP
.Vb 2
\&  cat bigfile | parallel \-\-pipe \-\-files sort |\e
\&    parallel \-Xj1 sort \-m {} \*(Aq;\*(Aq rm {} >bigfile.sort
.Ve
.PP
Here \fBbigfile\fR is split into blocks of around 1MB, each block ending
in '\en' (which is the default for \fB\-\-recend\fR). Each block is passed
to \fBsort\fR and the output from \fBsort\fR is saved into files. These
files are passed to the second \fBparallel\fR that runs \fBsort \-m\fR on the
files before it removes the files. The output is saved to
\&\fBbigfile.sort\fR.
.PP
\&\s-1GNU \s0\fBparallel\fR's \fB\-\-pipe\fR maxes out at around 100 MB/s because every
byte has to be copied through \s-1GNU \s0\fBparallel\fR. But if \fBbigfile\fR is a
real (seekable) file \s-1GNU \s0\fBparallel\fR can by-pass the copying and send
the parts directly to the program:
.PP
.Vb 2
\&  parallel \-\-pipepart \-\-block 100m \-a bigfile \-\-files sort |\e
\&    parallel \-Xj1 sort \-m {} \*(Aq;\*(Aq rm {} >bigfile.sort
.Ve
.SH "EXAMPLE: Running more than 250 jobs workaround"
.IX Header "EXAMPLE: Running more than 250 jobs workaround"
If you need to run a massive amount of jobs in parallel, then you will
likely hit the filehandle limit which is often around 250 jobs. If you
are super user you can raise the limit in /etc/security/limits.conf
but you can also use this workaround. The filehandle limit is per
process. That means that if you just spawn more \s-1GNU \s0\fBparallel\fRs then
each of them can run 250 jobs. This will spawn up to 2500 jobs:
.PP
.Vb 2
\&  cat myinput |\e
\&    parallel \-\-pipe \-N 50 \-\-round\-robin \-j50 parallel \-j50 your_prg
.Ve
.PP
This will spawn up to 62500 jobs (use with caution \- you need 64 \s-1GB
RAM\s0 to do this, and you may need to increase /proc/sys/kernel/pid_max):
.PP
.Vb 2
\&  cat myinput |\e
\&    parallel \-\-pipe \-N 250 \-\-round\-robin \-j250 parallel \-j250 your_prg
.Ve
.SH "EXAMPLE: Working as mutex and counting semaphore"
.IX Header "EXAMPLE: Working as mutex and counting semaphore"
The command \fBsem\fR is an alias for \fBparallel \-\-semaphore\fR.
.PP
A counting semaphore will allow a given number of jobs to be started
in the background.  When the number of jobs are running in the
background, \s-1GNU \s0\fBsem\fR will wait for one of these to complete before
starting another command. \fBsem \-\-wait\fR will wait for all jobs to
complete.
.PP
Run 10 jobs concurrently in the background:
.PP
.Vb 5
\&  for i in *.log ; do
\&    echo $i
\&    sem \-j10 gzip $i ";" echo done
\&  done
\&  sem \-\-wait
.Ve
.PP
A mutex is a counting semaphore allowing only one job to run. This
will edit the file \fImyfile\fR and prepends the file with lines with the
numbers 1 to 3.
.PP
.Vb 1
\&  seq 3 | parallel sem sed \-i \-e \*(Aqi{}\*(Aq myfile
.Ve
.PP
As \fImyfile\fR can be very big it is important only one process edits
the file at the same time.
.PP
Name the semaphore to have multiple different semaphores active at the
same time:
.PP
.Vb 1
\&  seq 3 | parallel sem \-\-id mymutex sed \-i \-e \*(Aqi{}\*(Aq myfile
.Ve
.SH "EXAMPLE: Mutex for a script"
.IX Header "EXAMPLE: Mutex for a script"
Assume a script is called from cron or from a web service, but only
one instance can be run at a time. With \fBsem\fR and \fB\-\-shebang\-wrap\fR
the script can be made to wait for other instances to finish. Here in
\&\fBbash\fR:
.PP
.Vb 1
\&  #!/usr/bin/sem \-\-shebang\-wrap \-u \-\-id $0 \-\-fg /bin/bash
\&  
\&  echo This will run
\&  sleep 5
\&  echo exclusively
.Ve
.PP
Here \fBperl\fR:
.PP
.Vb 1
\&  #!/usr/bin/sem \-\-shebang\-wrap \-u \-\-id $0 \-\-fg /usr/bin/perl
\&  
\&  print "This will run ";
\&  sleep 5;
\&  print "exclusively\en";
.Ve
.PP
Here \fBpython\fR:
.PP
.Vb 1
\&  #!/usr/local/bin/sem \-\-shebang\-wrap \-u \-\-id $0 \-\-fg /usr/bin/python
\&  
\&  import time
\&  print "This will run ";
\&  time.sleep(5)
\&  print "exclusively";
.Ve
.SH "EXAMPLE: Start editor with filenames from stdin (standard input)"
.IX Header "EXAMPLE: Start editor with filenames from stdin (standard input)"
You can use \s-1GNU \s0\fBparallel\fR to start interactive programs like emacs or vi:
.PP
.Vb 2
\&  cat filelist | parallel \-\-tty \-X emacs
\&  cat filelist | parallel \-\-tty \-X vi
.Ve
.PP
If there are more files than will fit on a single command line, the
editor will be started again with the remaining files.
.SH "EXAMPLE: Running sudo"
.IX Header "EXAMPLE: Running sudo"
\&\fBsudo\fR requires a password to run a command as root. It caches the
access, so you only need to enter the password again if you have not
used \fBsudo\fR for a while.
.PP
The command:
.PP
.Vb 1
\&  parallel sudo echo ::: This is a bad idea
.Ve
.PP
is no good, as you would be prompted for the sudo password for each of
the jobs. You can either do:
.PP
.Vb 2
\&  sudo echo This
\&  parallel sudo echo ::: is a good idea
.Ve
.PP
or:
.PP
.Vb 1
\&  sudo parallel echo ::: This is a good idea
.Ve
.PP
This way you only have to enter the sudo password once.
.SH "EXAMPLE: GNU Parallel as queue system/batch manager"
.IX Header "EXAMPLE: GNU Parallel as queue system/batch manager"
\&\s-1GNU \s0\fBparallel\fR can work as a simple job queue system or batch manager.
The idea is to put the jobs into a file and have \s-1GNU \s0\fBparallel\fR read
from that continuously. As \s-1GNU \s0\fBparallel\fR will stop at end of file we
use \fBtail\fR to continue reading:
.PP
.Vb 1
\&  true >jobqueue; tail \-n+0 \-f jobqueue | parallel
.Ve
.PP
To submit your jobs to the queue:
.PP
.Vb 1
\&  echo my_command my_arg >> jobqueue
.Ve
.PP
You can of course use \fB\-S\fR to distribute the jobs to remote
computers:
.PP
.Vb 1
\&  true >jobqueue; tail \-n+0 \-f jobqueue | parallel \-S ..
.Ve
.PP
There is a a small issue when using \s-1GNU \s0\fBparallel\fR as queue
system/batch manager: You have to submit JobSlot number of jobs before
they will start, and after that you can submit one at a time, and job
will start immediately if free slots are available.  Output from the
running or completed jobs are held back and will only be printed when
JobSlots more jobs has been started (unless you use \-\-ungroup or \-u,
in which case the output from the jobs are printed immediately).
E.g. if you have 10 jobslots then the output from the first completed
job will only be printed when job 11 has started, and the output of
second completed job will only be printed when job 12 has started.
.PP
To use \fB\-\-eof\fR to make \s-1GNU \s0\fBparallel\fR exit, \fBtail\fR also needs to be
forced to exit:
.PP
.Vb 4
\&  tail \-n+0 \-f command\-list.txt |
\&    (parallel \-\-eof=EXIT {}; echo Parallel is now done;
\&     (seq 1000 >> command\-list.txt &);
\&    echo Done appending dummy data forcing tail to exit)
.Ve
.SH "EXAMPLE: GNU Parallel as dir processor"
.IX Header "EXAMPLE: GNU Parallel as dir processor"
If you have a dir in which users drop files that needs to be processed
you can do this on GNU/Linux (If you know what \fBinotifywait\fR is
called on other platforms file a bug report):
.PP
.Vb 2
\&  inotifywait \-q \-m \-r \-e MOVED_TO \-e CLOSE_WRITE \-\-format %w%f my_dir |\e
\&    parallel \-u echo
.Ve
.PP
This will run the command \fBecho\fR on each file put into \fBmy_dir\fR or
subdirs of \fBmy_dir\fR.
.PP
You can of course use \fB\-S\fR to distribute the jobs to remote
computers:
.PP
.Vb 2
\&  inotifywait \-q \-m \-r \-e MOVED_TO \-e CLOSE_WRITE \-\-format %w%f my_dir |\e
\&    parallel \-S ..  \-u echo
.Ve
.PP
If the files to be processed are in a tar file then unpacking one file
and processing it immediately may be faster than first unpacking all
files. Set up the dir processor as above and unpack into the dir.
.PP
Using \s-1GNU\s0 Parallel as dir processor has the same limitations as using
\&\s-1GNU\s0 Parallel as queue system/batch manager.
.SH "QUOTING"
.IX Header "QUOTING"
\&\s-1GNU \s0\fBparallel\fR is very liberal in quoting. You only need to quote
characters that have special meaning in shell:
.PP
.Vb 1
\&  ( ) $ \` \*(Aq " < > ; | \e
.Ve
.PP
and depending on context these needs to be quoted, too:
.PP
.Vb 1
\&  ~ & # ! ? space * {
.Ve
.PP
Therefore most people will never need more quoting than putting '\e'
in front of the special characters.
.PP
Often you can simply put \e' around every ':
.PP
.Vb 1
\&  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq file
.Ve
.PP
can be quoted:
.PP
.Vb 1
\&  parallel perl \-ne \e\*(Aq\*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq\e\*(Aq ::: file
.Ve
.PP
However, when you want to use a shell variable you need to quote the
$\-sign. Here is an example using \f(CW$PARALLEL_SEQ\fR. This variable is set
by \s-1GNU \s0\fBparallel\fR itself, so the evaluation of the $ must be done by
the sub shell started by \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 1
\&  seq 10 | parallel \-N2 echo seq:\e$PARALLEL_SEQ arg1:{1} arg2:{2}
.Ve
.PP
If the variable is set before \s-1GNU \s0\fBparallel\fR starts you can do this:
.PP
.Vb 2
\&  VAR=this_is_set_before_starting
\&  echo test | parallel echo {} $VAR
.Ve
.PP
Prints: \fBtest this_is_set_before_starting\fR
.PP
It is a little more tricky if the variable contains more than one space in a row:
.PP
.Vb 2
\&  VAR="two  spaces  between  each  word"
\&  echo test | parallel echo {} \e\*(Aq"$VAR"\e\*(Aq
.Ve
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
If the variable should not be evaluated by the shell starting \s-1GNU
\&\s0\fBparallel\fR but be evaluated by the sub shell started by \s-1GNU
\&\s0\fBparallel\fR, then you need to quote it:
.PP
.Vb 1
\&  echo test | parallel VAR=this_is_set_after_starting \e; echo {} \e$VAR
.Ve
.PP
Prints: \fBtest this_is_set_after_starting\fR
.PP
It is a little more tricky if the variable contains space:
.PP
.Vb 2
\&  echo test |\e
\&    parallel VAR=\*(Aq"two  spaces  between  each  word"\*(Aq echo {} \e\*(Aq"$VAR"\e\*(Aq
.Ve
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
$$ is the shell variable containing the process id of the shell. This
will print the process id of the shell running \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 1
\&  seq 10 | parallel echo $$
.Ve
.PP
And this will print the process ids of the sub shells started by \s-1GNU
\&\s0\fBparallel\fR.
.PP
.Vb 1
\&  seq 10 | parallel echo \e$\e$
.Ve
.PP
If the special characters should not be evaluated by the sub shell
then you need to protect it against evaluation from both the shell
starting \s-1GNU \s0\fBparallel\fR and the sub shell:
.PP
.Vb 1
\&  echo test | parallel echo {} \e\e\e$VAR
.Ve
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
\&\s-1GNU \s0\fBparallel\fR can protect against evaluation by the sub shell by
using \-q:
.PP
.Vb 1
\&  echo test | parallel \-q echo {} \e$VAR
.Ve
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
This is particularly useful if you have lots of quoting. If you want to run a perl script like this:
.PP
.Vb 1
\&  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq file
.Ve
.PP
It needs to be quoted like one of these:
.PP
.Vb 2
\&  ls | parallel perl \-ne \*(Aq/^\e\eS+\e\es+\e\eS+\e$/\e and\e print\e \e$ARGV,\e"\e\en\e"\*(Aq
\&  ls | parallel perl \-ne \e\*(Aq\*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq\e\*(Aq
.Ve
.PP
Notice how spaces, \e's, "'s, and $'s need to be quoted. \s-1GNU \s0\fBparallel\fR
can do the quoting by using option \-q:
.PP
.Vb 1
\&  ls | parallel \-q  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq
.Ve
.PP
However, this means you cannot make the sub shell interpret special
characters. For example because of \fB\-q\fR this \s-1WILL NOT WORK:\s0
.PP
.Vb 2
\&  ls *.gz | parallel \-q "zcat {} >{.}"
\&  ls *.gz | parallel \-q "zcat {} | bzip2 >{.}.bz2"
.Ve
.PP
because > and | need to be interpreted by the sub shell.
.PP
If you get errors like:
.PP
.Vb 4
\&  sh: \-c: line 0: syntax error near unexpected token
\&  sh: Syntax error: Unterminated quoted string
\&  sh: \-c: line 0: unexpected EOF while looking for matching \`\*(Aq\*(Aq
\&  sh: \-c: line 1: syntax error: unexpected end of file
.Ve
.PP
then you might try using \fB\-q\fR.
.PP
If you are using \fBbash\fR process substitution like \fB<(cat foo)\fR then
you may try \fB\-q\fR and prepending \fIcommand\fR with \fBbash \-c\fR:
.PP
.Vb 1
\&  ls | parallel \-q bash \-c \*(Aqwc \-c <(echo {})\*(Aq
.Ve
.PP
Or for substituting output:
.PP
.Vb 2
\&  ls | parallel \-q bash \-c \e
\&    \*(Aqtar c {} | tee >(gzip >{}.tar.gz) | bzip2 >{}.tar.bz2\*(Aq
.Ve
.PP
\&\fBConclusion\fR: To avoid dealing with the quoting problems it may be
easier just to write a small script or a function (remember to
\&\fBexport \-f\fR the function) and have \s-1GNU \s0\fBparallel\fR call that.
.SH "LIST RUNNING JOBS"
.IX Header "LIST RUNNING JOBS"
If you want a list of the jobs currently running you can run:
.PP
.Vb 1
\&  killall \-USR1 parallel
.Ve
.PP
\&\s-1GNU \s0\fBparallel\fR will then print the currently running jobs on stderr
(standard error).
.SH "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
.IX Header "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
If you regret starting a lot of jobs you can simply break \s-1GNU \s0\fBparallel\fR,
but if you want to make sure you do not have half-completed jobs you
should send the signal \fB\s-1SIGTERM\s0\fR to \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 1
\&  killall \-TERM parallel
.Ve
.PP
This will tell \s-1GNU \s0\fBparallel\fR to not start any new jobs, but wait until
the currently running jobs are finished before exiting.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.ie n .IP "$PARALLEL_PID" 9
.el .IP "\f(CW$PARALLEL_PID\fR" 9
.IX Item "$PARALLEL_PID"
The environment variable \f(CW$PARALLEL_PID\fR is set by \s-1GNU \s0\fBparallel\fR and
is visible to the jobs started from \s-1GNU \s0\fBparallel\fR. This makes it
possible for the jobs to communicate directly to \s-1GNU \s0\fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct
shell.
.Sp
\&\fBExample:\fR If each of the jobs tests a solution and one of jobs finds
the solution the job can tell \s-1GNU \s0\fBparallel\fR not to start more jobs
by: \fBkill \-TERM \f(CB$PARALLEL_PID\fB\fR. This only works on the local
computer.
.ie n .IP "$PARALLEL_SHELL" 9
.el .IP "\f(CW$PARALLEL_SHELL\fR" 9
.IX Item "$PARALLEL_SHELL"
Use this shell the shell for the commands run by \s-1GNU\s0 Parallel:
.RS 9
.IP "\(bu" 2
\&\f(CW$PARALLEL_SHELL\fR. If undefined use:
.IP "\(bu" 2
The shell that started \s-1GNU\s0 Parallel. If that cannot be determined:
.IP "\(bu" 2
\&\f(CW$SHELL\fR. If undefined use:
.IP "\(bu" 2
/bin/sh
.RE
.RS 9
.RE
.ie n .IP "$PARALLEL_SEQ" 9
.el .IP "\f(CW$PARALLEL_SEQ\fR" 9
.IX Item "$PARALLEL_SEQ"
\&\f(CW$PARALLEL_SEQ\fR will be set to the sequence number of the job
running. Remember to quote the $, so it gets evaluated by the correct
shell.
.Sp
\&\fBExample:\fR
.Sp
.Vb 2
\&  seq 10 | parallel \-N2 \e
\&    echo seq:\*(Aq$\*(AqPARALLEL_SEQ arg1:{1} arg2:{2}
.Ve
.ie n .IP "$TMPDIR" 9
.el .IP "\f(CW$TMPDIR\fR" 9
.IX Item "$TMPDIR"
Directory for temporary files. See: \fB\-\-tmpdir\fR.
.ie n .IP "$PARALLEL" 9
.el .IP "\f(CW$PARALLEL\fR" 9
.IX Item "$PARALLEL"
The environment variable \f(CW$PARALLEL\fR will be used as default options for
\&\s-1GNU \s0\fBparallel\fR. If the variable contains special shell characters
(e.g. $, *, or space) then these need to be to be escaped with \e.
.Sp
\&\fBExample:\fR
.Sp
.Vb 2
\&  cat list | parallel \-j1 \-k \-v ls
\&  cat list | parallel \-j1 \-k \-v \-S"myssh user@server" ls
.Ve
.Sp
can be written as:
.Sp
.Vb 3
\&  cat list | PARALLEL="\-kvj1" parallel ls
\&  cat list | PARALLEL=\*(Aq\-kvj1 \-S myssh\e user@server\*(Aq \e
\&    parallel echo
.Ve
.Sp
Notice the \e in the middle is needed because 'myssh' and 'user@server'
must be one argument.
.SH "DEFAULT PROFILE (CONFIG FILE)"
.IX Header "DEFAULT PROFILE (CONFIG FILE)"
The global configuration file /etc/parallel/config, followed by user
configuration file ~/.parallel/config (formerly known as .parallelrc)
will be read in turn if they exist.  Lines starting with '#' will be
ignored. The format can follow that of the environment variable
\&\f(CW$PARALLEL\fR, but it is often easier to simply put each option on its own
line.
.PP
Options on the command line take precedence, followed by the
environment variable \f(CW$PARALLEL\fR, user configuration file
~/.parallel/config, and finally the global configuration file
/etc/parallel/config.
.PP
Note that no file that is read for options, nor the environment
variable \f(CW$PARALLEL\fR, may contain retired options such as \fB\-\-tollef\fR.
.SH "PROFILE FILES"
.IX Header "PROFILE FILES"
If \fB\-\-profile\fR set, \s-1GNU \s0\fBparallel\fR will read the profile from that
file rather than the global or user configuration files. You can have
multiple \fB\-\-profiles\fR.
.PP
Example: Profile for running a command on every sshlogin in
~/.ssh/sshlogins and prepend the output with the sshlogin:
.PP
.Vb 2
\&  echo \-\-tag \-S .. \-\-nonall > ~/.parallel/n
\&  parallel \-Jn uptime
.Ve
.PP
Example: Profile for running every command with \fB\-j\-1\fR and \fBnice\fR
.PP
.Vb 2
\&  echo \-j\-1 nice > ~/.parallel/nice_profile
\&  parallel \-J nice_profile bzip2 \-9 ::: *
.Ve
.PP
Example: Profile for running a perl script before every command:
.PP
.Vb 3
\&  echo "perl \-e \*(Aq\e$a=\e$\e$; print \e$a,\e" \e",\*(Aq\e$PARALLEL_SEQ\*(Aq,\e" \e";\*(Aq;" \e
\&    > ~/.parallel/pre_perl
\&  parallel \-J pre_perl echo ::: *
.Ve
.PP
Note how the $ and " need to be quoted using \e.
.PP
Example: Profile for running distributed jobs with \fBnice\fR on the
remote computers:
.PP
.Vb 2
\&  echo \-S .. nice > ~/.parallel/dist
\&  parallel \-J dist \-\-trc {.}.bz2 bzip2 \-9 ::: *
.Ve
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
If \fB\-\-halt\-on\-error\fR 0 or not specified:
.IP "0" 6
All jobs ran without error.
.IP "1\-253" 6
.IX Item "1-253"
Some of the jobs failed. The exit status gives the number of failed jobs
.IP "254" 6
.IX Item "254"
More than 253 jobs failed.
.IP "255" 6
.IX Item "255"
Other error.
.PP
If \fB\-\-halt\-on\-error\fR 1 or 2: Exit status of the failing job.
.SH "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
.IX Header "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
There are a lot programs with some of the functionality of \s-1GNU
\&\s0\fBparallel\fR. \s-1GNU \s0\fBparallel\fR strives to include the best of the
functionality without sacrificing ease of use.
.SS "\s-1SUMMARY TABLE\s0"
.IX Subsection "SUMMARY TABLE"
The following features are in some of the comparable tools:
.PP
Inputs
 I1. Arguments can be read from stdin
 I2. Arguments can be read from a file
 I3. Arguments can be read from multiple files
 I4. Arguments can be read from command line
 I5. Arguments can be read from a table
 I6. Arguments can be read from the same file using #! (shebang)
 I7. Line oriented input as default (Quoting of special chars not needed)
.PP
Manipulation of input
 M1. Composed command
 M2. Multiple arguments can fill up an execution line
 M3. Arguments can be put anywhere in the execution line
 M4. Multiple arguments can be put anywhere in the execution line
 M5. Arguments can be replaced with context
 M6. Input can be treated as complete execution line
.PP
Outputs
 O1. Grouping output so output from different jobs do not mix
 O2. Send stderr (standard error) to stderr (standard error)
 O3. Send stdout (standard output) to stdout (standard output)
 O4. Order of output can be same as order of input
 O5. Stdout only contains stdout (standard output) from the command
 O6. Stderr only contains stderr (standard error) from the command
.PP
Execution
 E1. Running jobs in parallel
 E2. List running jobs
 E3. Finish running jobs, but do not start new jobs
 E4. Number of running jobs can depend on number of cpus
 E5. Finish running jobs, but do not start new jobs after first failure
 E6. Number of running jobs can be adjusted while running
.PP
Remote execution
 R1. Jobs can be run on remote computers
 R2. Basefiles can be transferred
 R3. Argument files can be transferred
 R4. Result files can be transferred
 R5. Cleanup of transferred files
 R6. No config files needed
 R7. Do not run more than \s-1SSHD\s0's MaxStartups can handle
 R8. Configurable \s-1SSH\s0 command
 R9. Retry if connection breaks occasionally
.PP
Semaphore
 S1. Possibility to work as a mutex
 S2. Possibility to work as a counting semaphore
.PP
Legend
 \- = no
 x = not applicable
 \s-1ID\s0 = yes
.PP
As every new version of the programs are not tested the table may be
outdated. Please file a bug-report if you find errors (See \s-1REPORTING
BUGS\s0).
.PP
parallel:
I1 I2 I3 I4 I5 I6 I7
M1 M2 M3 M4 M5 M6
O1 O2 O3 O4 O5 O6
E1 E2 E3 E4 E5 E6
R1 R2 R3 R4 R5 R6 R7 R8 R9
S1 S2
.PP
xargs:
I1 I2 \-  \-  \-  \-  \-
\&\-  M2 M3 \-  \-  \-
\&\-  O2 O3 \-  O5 O6
E1 \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  x  \-  \-  \-
\&\-  \-
.PP
find \-exec:
\&\-  \-  \-  x  \-  x  \-
\&\-  M2 M3 \-  \-  \-  \-
\&\-  O2 O3 O4 O5 O6
\&\-  \-  \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  \-  \-  \-  \-
x  x
.PP
make \-j:
\&\-  \-  \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  \-
O1 O2 O3 \-  x  O6
E1 \-  \-  \-  E5 \-
\&\-  \-  \-  \-  \-  \-  \-  \-  \-
\&\-  \-
.PP
ppss:
I1 I2 \-  \-  \-  \-  I7
M1 \-  M3 \-  \-  M6
O1 \-  \-  x  \-  \-
E1 E2 ?E3 E4 \- \-
R1 R2 R3 R4 \-  \-  ?R7 ? ?
\&\-  \-
.PP
pexec:
I1 I2 \-  I4 I5 \-  \-
M1 \-  M3 \-  \-  M6
O1 O2 O3 \-  O5 O6
E1 \-  \-  E4 \-  E6
R1 \-  \-  \-  \-  R6 \-  \-  \-
S1 \-
.PP
xjobs: \s-1TODO \-\s0 Please file a bug-report if you know what features xjobs
supports (See \s-1REPORTING BUGS\s0).
.PP
prll: \s-1TODO \-\s0 Please file a bug-report if you know what features prll
supports (See \s-1REPORTING BUGS\s0).
.PP
dxargs: \s-1TODO \-\s0 Please file a bug-report if you know what features dxargs
supports (See \s-1REPORTING BUGS\s0).
.PP
mdm/middelman: \s-1TODO \-\s0 Please file a bug-report if you know what
features mdm/middelman supports (See \s-1REPORTING BUGS\s0).
.PP
xapply: \s-1TODO \-\s0 Please file a bug-report if you know what features xapply
supports (See \s-1REPORTING BUGS\s0).
.PP
paexec: \s-1TODO \-\s0 Please file a bug-report if you know what features paexec
supports (See \s-1REPORTING BUGS\s0).
.PP
ladon: \s-1TODO \-\s0 Please file a bug-report if you know what features ladon
supports (See \s-1REPORTING BUGS\s0).
.PP
ClusterSSH: \s-1TODO \-\s0 Please file a bug-report if you know what features ClusterSSH
supports (See \s-1REPORTING BUGS\s0).
.SS "\s-1DIFFERENCES BETWEEN\s0 xargs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xargs AND GNU Parallel"
\&\fBxargs\fR offers some of the same possibilities as \s-1GNU \s0\fBparallel\fR.
.PP
\&\fBxargs\fR deals badly with special characters (such as space, ' and
"). To see the problem try this:
.PP
.Vb 5
\&  touch important_file
\&  touch \*(Aqnot important_file\*(Aq
\&  ls not* | xargs rm
\&  mkdir \-p "My brother\*(Aqs 12\e" records"
\&  ls | xargs rmdir
.Ve
.PP
You can specify \fB\-0\fR, but many input generators are not
optimized for using \fB\s-1NUL\s0\fR as separator but are optimized for
\&\fBnewline\fR as separator. E.g \fBhead\fR, \fBtail\fR, \fBawk\fR, \fBls\fR, \fBecho\fR,
\&\fBsed\fR, \fBtar \-v\fR, \fBperl\fR (\fB\-0\fR and \e0 instead of \en), \fBlocate\fR
(requires using \fB\-0\fR), \fBfind\fR (requires using \fB\-print0\fR), \fBgrep\fR
(requires user to use \fB\-z\fR or \fB\-Z\fR), \fBsort\fR (requires using \fB\-z\fR).
.PP
So \s-1GNU \s0\fBparallel\fR's newline separation can be emulated with:
.PP
\&\fBcat | xargs \-d \*(L"\en\*(R" \-n1 \f(BIcommand\fB\fR
.PP
\&\fBxargs\fR can run a given number of jobs in parallel, but has no
support for running number-of-cpu-cores jobs in parallel.
.PP
\&\fBxargs\fR has no support for grouping the output, therefore output may
run together, e.g. the first half of a line is from one process and
the last half of the line is from another process. The example
\&\fBParallel grep\fR cannot be done reliably with \fBxargs\fR because of
this. To see this in action try:
.PP
.Vb 10
\&  parallel perl \-e \*(Aq\e$a=\e"1{}\e"x10000000\e;print\e \e$a,\e"\e\en\e"\*(Aq \*(Aq>\*(Aq {} \e
\&    ::: a b c d e f
\&  ls \-l a b c d e f
\&  parallel \-kP4 \-n1 grep 1 > out.par ::: a b c d e f
\&  echo a b c d e f | xargs \-P4 \-n1 grep 1 > out.xargs\-unbuf
\&  echo a b c d e f | \e
\&    xargs \-P4 \-n1 grep \-\-line\-buffered 1 > out.xargs\-linebuf
\&  echo a b c d e f | xargs \-n1 grep 1 > out.xargs\-serial
\&  ls \-l out*
\&  md5sum out*
.Ve
.PP
\&\fBxargs\fR has no support for keeping the order of the output, therefore
if running jobs in parallel using \fBxargs\fR the output of the second
job cannot be postponed till the first job is done.
.PP
\&\fBxargs\fR has no support for running jobs on remote computers.
.PP
\&\fBxargs\fR has no support for context replace, so you will have to create the
arguments.
.PP
If you use a replace string in \fBxargs\fR (\fB\-I\fR) you can not force
\&\fBxargs\fR to use more than one argument.
.PP
Quoting in \fBxargs\fR works like \fB\-q\fR in \s-1GNU \s0\fBparallel\fR. This means
composed commands and redirection require using \fBbash \-c\fR.
.PP
.Vb 2
\&  ls | parallel "wc {} >{}.wc"
\&  ls | parallel "echo {}; ls {}|wc"
.Ve
.PP
becomes (assuming you have 8 cores)
.PP
.Vb 2
\&  ls | xargs \-d "\en" \-P8 \-I {} bash \-c "wc {} >{}.wc"
\&  ls | xargs \-d "\en" \-P8 \-I {} bash \-c "echo {}; ls {}|wc"
.Ve
.SS "\s-1DIFFERENCES BETWEEN\s0 find \-exec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN find -exec AND GNU Parallel"
\&\fBfind \-exec\fR offer some of the same possibilities as \s-1GNU \s0\fBparallel\fR.
.PP
\&\fBfind \-exec\fR only works on files. So processing other input (such as
hosts or URLs) will require creating these inputs as files. \fBfind
\&\-exec\fR has no support for running commands in parallel.
.SS "\s-1DIFFERENCES BETWEEN\s0 make \-j \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN make -j AND GNU Parallel"
\&\fBmake \-j\fR can run jobs in parallel, but requires a crafted Makefile
to do this. That results in extra quoting to get filename containing
newline to work correctly.
.PP
\&\fBmake \-j\fR has no support for grouping the output, therefore output
may run together, e.g. the first half of a line is from one process
and the last half of the line is from another process. The example
\&\fBParallel grep\fR cannot be done reliably with \fBmake \-j\fR because of
this.
.PP
(Very early versions of \s-1GNU \s0\fBparallel\fR were coincidently implemented
using \fBmake \-j\fR).
.SS "\s-1DIFFERENCES BETWEEN\s0 ppss \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN ppss AND GNU Parallel"
\&\fBppss\fR is also a tool for running jobs in parallel.
.PP
The output of \fBppss\fR is status information and thus not useful for
using as input for another command. The output from the jobs are put
into files.
.PP
The argument replace string ($ITEM) cannot be changed. Arguments must
be quoted \- thus arguments containing special characters (space '"&!*)
may cause problems. More than one argument is not supported. File
names containing newlines are not processed correctly. When reading
input from a file null cannot be used as a terminator. \fBppss\fR needs
to read the whole input file before starting any jobs.
.PP
Output and status information is stored in ppss_dir and thus requires
cleanup when completed. If the dir is not removed before running
\&\fBppss\fR again it may cause nothing to happen as \fBppss\fR thinks the
task is already done. \s-1GNU \s0\fBparallel\fR will normally not need cleaning
up if running locally and will only need cleaning up if stopped
abnormally and running remote (\fB\-\-cleanup\fR may not complete if
stopped abnormally). The example \fBParallel grep\fR would require extra
postprocessing if written using \fBppss\fR.
.PP
For remote systems \s-1PPSS\s0 requires 3 steps: config, deploy, and
start. \s-1GNU \s0\fBparallel\fR only requires one step.
.PP
\fI\s-1EXAMPLES FROM\s0 ppss \s-1MANUAL\s0\fR
.IX Subsection "EXAMPLES FROM ppss MANUAL"
.PP
Here are the examples from \fBppss\fR's manual page with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR ./ppss.sh standalone \-d /path/to/files \-c 'gzip '
.PP
\&\fB1\fR find /path/to/files \-type f | parallel gzip
.PP
\&\fB2\fR ./ppss.sh standalone \-d /path/to/files \-c 'cp \*(L"$ITEM\*(R" /destination/dir '
.PP
\&\fB2\fR find /path/to/files \-type f | parallel cp {} /destination/dir
.PP
\&\fB3\fR ./ppss.sh standalone \-f list\-of\-urls.txt \-c 'wget \-q '
.PP
\&\fB3\fR parallel \-a list\-of\-urls.txt wget \-q
.PP
\&\fB4\fR ./ppss.sh standalone \-f list\-of\-urls.txt \-c 'wget \-q \*(L"$ITEM\*(R"'
.PP
\&\fB4\fR parallel \-a list\-of\-urls.txt wget \-q {}
.PP
\&\fB5\fR ./ppss config \-C config.cfg \-c 'encode.sh ' \-d /source/dir \-m
192.168.1.100 \-u ppss \-k ppss\-key.key \-S ./encode.sh \-n nodes.txt \-o
/some/output/dir \-\-upload \-\-download ; ./ppss deploy \-C config.cfg ;
\&./ppss start \-C config
.PP
\&\fB5\fR # parallel does not use configs. If you want a different username put it in nodes.txt: user@hostname
.PP
\&\fB5\fR find source/dir \-type f | parallel \-\-sshloginfile nodes.txt \-\-trc {.}.mp3 lame \-a {} \-o {.}.mp3 \-\-preset standard \-\-quiet
.PP
\&\fB6\fR ./ppss stop \-C config.cfg
.PP
\&\fB6\fR killall \-TERM parallel
.PP
\&\fB7\fR ./ppss pause \-C config.cfg
.PP
\&\fB7\fR Press: CTRL-Z or killall \-SIGTSTP parallel
.PP
\&\fB8\fR ./ppss continue \-C config.cfg
.PP
\&\fB8\fR Enter: fg or killall \-SIGCONT parallel
.PP
\&\fB9\fR ./ppss.sh status \-C config.cfg
.PP
\&\fB9\fR killall \-SIGUSR2 parallel
.SS "\s-1DIFFERENCES BETWEEN\s0 pexec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN pexec AND GNU Parallel"
\&\fBpexec\fR is also a tool for running jobs in parallel.
.PP
\fI\s-1EXAMPLES FROM\s0 pexec \s-1MANUAL\s0\fR
.IX Subsection "EXAMPLES FROM pexec MANUAL"
.PP
Here are the examples from \fBpexec\fR's info page with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR pexec \-o sqrt\-%s.dat \-p \*(L"$(seq 10)\*(R" \-e \s-1NUM\s0 \-n 4 \-c \*(-- \e
  'echo \*(L"scale=10000;sqrt($NUM)\*(R" | bc'
.PP
\&\fB1\fR seq 10 | parallel \-j4 'echo \*(L"scale=10000;sqrt({})\*(R" | bc > sqrt\-{}.dat'
.PP
\&\fB2\fR pexec \-p \*(L"$(ls myfiles*.ext)\*(R" \-i \f(CW%s\fR \-o \f(CW%s\fR.sort \*(-- sort
.PP
\&\fB2\fR ls myfiles*.ext | parallel sort {} \*(L">{}.sort\*(R"
.PP
\&\fB3\fR pexec \-f image.list \-n auto \-e B \-u star.log \-c \*(-- \e
  'fistar \f(CW$B\fR.fits \-f 100 \-F id,x,y,flux \-o \f(CW$B\fR.star'
.PP
\&\fB3\fR parallel \-a image.list \e
  'fistar {}.fits \-f 100 \-F id,x,y,flux \-o {}.star' 2>star.log
.PP
\&\fB4\fR pexec \-r *.png \-e \s-1IMG\s0 \-c \-o \- \*(-- \e
  'convert \f(CW$IMG\fR ${IMG%.png}.jpeg ; \*(L"echo \f(CW$IMG:\fR done\*(R"'
.PP
\&\fB4\fR ls *.png | parallel 'convert {} {.}.jpeg; echo {}: done'
.PP
\&\fB5\fR pexec \-r *.png \-i \f(CW%s\fR \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB5\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {}.jpg'
.PP
\&\fB6\fR for p in *.png ; do echo ${p%.png} ; done | \e
  pexec \-f \- \-i \f(CW%s\fR.png \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB6\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {.}.jpg'
.PP
\&\fB7\fR LIST=$(for p in *.png ; do echo ${p%.png} ; done)
  pexec \-r \f(CW$LIST\fR \-i \f(CW%s\fR.png \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB7\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {.}.jpg'
.PP
\&\fB8\fR pexec \-n 8 \-r *.jpg \-y unix \-e \s-1IMG\s0 \-c \e
  'pexec \-j \-m blockread \-d \f(CW$IMG\fR | \e
  jpegtopnm | pnmscale 0.5 | pnmtojpeg | \e
  pexec \-j \-m blockwrite \-s th_$IMG'
.PP
\&\fB8\fR Combining \s-1GNU \s0\fBparallel\fR and \s-1GNU \s0\fBsem\fR.
.PP
\&\fB8\fR ls *jpg | parallel \-j8 'sem \-\-id blockread cat {} | jpegtopnm |' \e
  'pnmscale 0.5 | pnmtojpeg | sem \-\-id blockwrite cat > th_{}'
.PP
\&\fB8\fR If reading and writing is done to the same disk, this may be
faster as only one process will be either reading or writing:
.PP
\&\fB8\fR ls *jpg | parallel \-j8 'sem \-\-id diskio cat {} | jpegtopnm |' \e
  'pnmscale 0.5 | pnmtojpeg | sem \-\-id diskio cat > th_{}'
.SS "\s-1DIFFERENCES BETWEEN\s0 xjobs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xjobs AND GNU Parallel"
\&\fBxjobs\fR is also a tool for running jobs in parallel. It only supports
running jobs on your local computer.
.PP
\&\fBxjobs\fR deals badly with special characters just like \fBxargs\fR. See
the section \fB\s-1DIFFERENCES BETWEEN\s0 xargs \s-1AND GNU\s0 Parallel\fR.
.PP
Here are the examples from \fBxjobs\fR's man page with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR ls \-1 *.zip | xjobs unzip
.PP
\&\fB1\fR ls *.zip | parallel unzip
.PP
\&\fB2\fR ls \-1 *.zip | xjobs \-n unzip
.PP
\&\fB2\fR ls *.zip | parallel unzip >/dev/null
.PP
\&\fB3\fR find . \-name '*.bak' | xjobs gzip
.PP
\&\fB3\fR find . \-name '*.bak' | parallel gzip
.PP
\&\fB4\fR ls \-1 *.jar | sed 's/\e(.*\e)/\e1 > \e1.idx/' | xjobs jar tf
.PP
\&\fB4\fR ls *.jar | parallel jar tf {} '>' {}.idx
.PP
\&\fB5\fR xjobs \-s script
.PP
\&\fB5\fR cat script | parallel
.PP
\&\fB6\fR mkfifo /var/run/my_named_pipe;
xjobs \-s /var/run/my_named_pipe &
echo unzip 1.zip >> /var/run/my_named_pipe;
echo tar cf /backup/myhome.tar /home/me >> /var/run/my_named_pipe
.PP
\&\fB6\fR mkfifo /var/run/my_named_pipe;
cat /var/run/my_named_pipe | parallel &
echo unzip 1.zip >> /var/run/my_named_pipe;
echo tar cf /backup/myhome.tar /home/me >> /var/run/my_named_pipe
.SS "\s-1DIFFERENCES BETWEEN\s0 prll \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN prll AND GNU Parallel"
\&\fBprll\fR is also a tool for running jobs in parallel. It does not
support running jobs on remote computers.
.PP
\&\fBprll\fR encourages using \s-1BASH\s0 aliases and \s-1BASH\s0 functions instead of
scripts. \s-1GNU \s0\fBparallel\fR will never support running aliases (see why
http://www.perlmonks.org/index.pl?node_id=484296). However, scripts,
composed commands, or functions exported with \fBexport \-f\fR work just
fine.
.PP
\&\fBprll\fR generates a lot of status information on stderr (standard
error) which makes it harder to use the stderr (standard error) output
of the job directly as input for another program.
.PP
Here is the example from \fBprll\fR's man page with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 2
\&  prll \-s \*(Aqmogrify \-flip $1\*(Aq *.jpg
\&  parallel mogrify \-flip ::: *.jpg
.Ve
.SS "\s-1DIFFERENCES BETWEEN\s0 dxargs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN dxargs AND GNU Parallel"
\&\fBdxargs\fR is also a tool for running jobs in parallel.
.PP
\&\fBdxargs\fR does not deal well with more simultaneous jobs than \s-1SSHD\s0's
MaxStartups. \fBdxargs\fR is only built for remote run jobs, but does not
support transferring of files.
.SS "\s-1DIFFERENCES BETWEEN\s0 mdm/middleman \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN mdm/middleman AND GNU Parallel"
middleman(mdm) is also a tool for running jobs in parallel.
.PP
Here are the shellscripts of http://mdm.berlios.de/usage.html ported
to \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 3
\&  seq 19 | parallel buffon \-o \- | sort \-n > result
\&  cat files | parallel cmd
\&  find dir \-execdir sem cmd {} \e;
.Ve
.SS "\s-1DIFFERENCES BETWEEN\s0 xapply \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xapply AND GNU Parallel"
\&\fBxapply\fR can run jobs in parallel on the local computer.
.PP
Here are the examples from \fBxapply\fR's man page with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR xapply '(cd \f(CW%1\fR && make all)' */
.PP
\&\fB1\fR parallel 'cd {} && make all' ::: */
.PP
\&\fB2\fR xapply \-f 'diff \f(CW%1\fR ../version5/%1' manifest | more
.PP
\&\fB2\fR parallel diff {} ../version5/{} < manifest | more
.PP
\&\fB3\fR xapply \-p/dev/null \-f 'diff \f(CW%1\fR \f(CW%2\fR' manifest1 checklist1
.PP
\&\fB3\fR parallel \-\-xapply diff {1} {2} :::: manifest1 checklist1
.PP
\&\fB4\fR xapply 'indent' *.c
.PP
\&\fB4\fR parallel indent ::: *.c
.PP
\&\fB5\fR find ~ksb/bin \-type f ! \-perm \-111 \-print | xapply \-f \-v 'chmod a+x' \-
.PP
\&\fB5\fR find ~ksb/bin \-type f ! \-perm \-111 \-print | parallel \-v chmod a+x
.PP
\&\fB6\fR find */ \-... | fmt 960 1024 | xapply \-f \-i /dev/tty 'vi' \-
.PP
\&\fB6\fR sh <(find */ \-... | parallel \-s 1024 echo vi)
.PP
\&\fB6\fR find */ \-... | parallel \-s 1024 \-Xuj1 vi
.PP
\&\fB7\fR find ... | xapply \-f \-5 \-i /dev/tty 'vi' \- \- \- \- \-
.PP
\&\fB7\fR sh <(find ... |parallel \-n5 echo vi)
.PP
\&\fB7\fR find ... |parallel \-n5 \-uj1 vi
.PP
\&\fB8\fR xapply \-fn "" /etc/passwd
.PP
\&\fB8\fR parallel \-k echo < /etc/passwd
.PP
\&\fB9\fR tr ':' '\e012' < /etc/passwd | xapply \-7 \-nf 'chown \f(CW%1\fR \f(CW%6\fR' \- \- \- \- \- \- \-
.PP
\&\fB9\fR tr ':' '\e012' < /etc/passwd | parallel \-N7 chown {1} {6}
.PP
\&\fB10\fR xapply '[ \-d \f(CW%1\fR/RCS ] || echo \f(CW%1\fR' */
.PP
\&\fB10\fR parallel '[ \-d {}/RCS ] || echo {}' ::: */
.PP
\&\fB11\fR xapply \-f '[ \-f \f(CW%1\fR ] && echo \f(CW%1\fR' List | ...
.PP
\&\fB11\fR parallel '[ \-f {} ] && echo {}' < List | ...
.SS "\s-1DIFFERENCES BETWEEN\s0 paexec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN paexec AND GNU Parallel"
\&\fBpaexec\fR can run jobs in parallel on both the local and remote computers.
.PP
\&\fBpaexec\fR requires commands to print a blank line as the last
output. This means you will have to write a wrapper for most programs.
.PP
\&\fBpaexec\fR has a job dependency facility so a job can depend on another
job to be executed successfully. Sort of a poor-man's \fBmake\fR.
.PP
Here are the examples from \fBpaexec\fR's example catalog with the equivalent
using \s-1GNU \s0\fBparallel\fR:
.IP "1_div_X_run:" 1
.IX Item "1_div_X_run:"
.Vb 2
\&  ../../paexec \-s \-l \-c "\`pwd\`/1_div_X_cmd" \-n +1 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq \`pwd\`/1_div_X_cmd <<EOF [...]
.Ve
.IP "all_substr_run:" 1
.IX Item "all_substr_run:"
.Vb 2
\&  ../../paexec \-lp \-c "\`pwd\`/all_substr_cmd" \-n +3 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq \`pwd\`/all_substr_cmd <<EOF [...]
.Ve
.IP "cc_wrapper_run:" 1
.IX Item "cc_wrapper_run:"
.Vb 8
\&  ../../paexec \-c "env CC=gcc CFLAGS=\-O2 \`pwd\`/cc_wrapper_cmd" \e
\&             \-n \*(Aqhost1 host2\*(Aq \e
\&             \-t \*(Aq/usr/bin/ssh \-x\*(Aq <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq "env CC=gcc CFLAGS=\-O2 \`pwd\`/cc_wrapper_cmd" \e
\&             \-S host1,host2 <<EOF [...]
\&  # This is not exactly the same, but avoids the wrapper
\&  parallel gcc \-O2 \-c \-o {.}.o {} \e
\&             \-S host1,host2 <<EOF [...]
.Ve
.IP "toupper_run:" 1
.IX Item "toupper_run:"
.Vb 4
\&  ../../paexec \-lp \-c "\`pwd\`/toupper_cmd" \-n +10 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq ./toupper_cmd <<EOF [...]
\&  # Without the wrapper:
\&  parallel echo {} \*(Aq| awk {print\e toupper\e(\e$0\e)}\*(Aq <<EOF [...]
.Ve
.SS "\s-1DIFFERENCES BETWEEN\s0 map \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN map AND GNU Parallel"
\&\fBmap\fR sees it as a feature to have less features and in doing so it
also handles corner cases incorrectly. A lot of \s-1GNU \s0\fBparallel\fR's code
is to handle corner cases correctly on every platform, so you will not
get a nasty surprise if a user for example saves a file called: \fIMy
brother's 12" records.txt\fR
.PP
\&\fBmap\fR's example showing how to deal with special characters fails on
special characters:
.PP
.Vb 1
\&  echo "The Cure" > My\e brother\e\*(Aqs\e 12\e"\e records
\&
\&  ls | \e
\&    map \*(Aqecho \-n \`gzip < "%" | wc \-c\`; echo \-n \*(Aq*100/\*(Aq; wc \-c < "%"\*(Aq | bc
.Ve
.PP
It works with \s-1GNU \s0\fBparallel\fR:
.PP
.Vb 2
\&  ls | \e
\&    parallel \*(Aqecho \-n \`gzip < {} | wc \-c\`; echo \-n \*(Aq*100/\*(Aq; wc \-c < {}\*(Aq | bc
.Ve
.PP
And you can even get the file name prepended:
.PP
.Vb 2
\&  ls | \e
\&    parallel \-\-tag \*(Aq(echo \-n \`gzip < {} | wc \-c\`\*(Aq*100/\*(Aq; wc \-c < {}) | bc\*(Aq
.Ve
.PP
\&\fBmap\fR has no support for grouping. So this gives the wrong results
without any warnings:
.PP
.Vb 9
\&  parallel perl \-e \*(Aq\e$a=\e"1{}\e"x10000000\e;print\e \e$a,\e"\e\en\e"\*(Aq \*(Aq>\*(Aq {} \e
\&    ::: a b c d e f
\&  ls \-l a b c d e f
\&  parallel \-kP4 \-n1 grep 1 > out.par ::: a b c d e f
\&  map \-p 4 \*(Aqgrep 1\*(Aq a b c d e f > out.map\-unbuf
\&  map \-p 4 \*(Aqgrep \-\-line\-buffered 1\*(Aq a b c d e f > out.map\-linebuf
\&  map \-p 1 \*(Aqgrep \-\-line\-buffered 1\*(Aq a b c d e f > out.map\-serial
\&  ls \-l out*
\&  md5sum out*
.Ve
.PP
The documentation shows a workaround, but not only does that mix
stdout (standard output) with stderr (standard error) it also fails
completely for certain jobs (and may even be considered less readable):
.PP
.Vb 1
\&  parallel echo \-n {} ::: 1 2 3
\&
\&  map \-p 4 \*(Aqecho \-n % 2>&1 | sed \-e "s/^/$$:/"\*(Aq 1 2 3 | sort | cut \-f2\- \-d:
.Ve
.PP
\&\fBmap\fR cannot handle bundled options: \fBmap \-vp 0 echo this fails\fR
.PP
\&\fBmap\fR does not have an argument separator on the command line, but
uses the first argument as command. This makes quoting harder which again
may affect readability. Compare:
.PP
.Vb 1
\&  map \-p 2 perl\e\e\e \-ne\e\e\e \e\e\e\*(Aq/^\e\e\e\eS+\e\e\e\es+\e\e\e\eS+\e\e\e$/\e\e\e and\e\e\e print\e\e\e \e\e\e$ARGV,\e\e\e"\e\e\e\en\e\e\e"\e\e\e\*(Aq *
\&
\&  parallel \-q perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq ::: *
.Ve
.PP
\&\fBmap\fR can do multiple arguments with context replace, but not without
context replace:
.PP
.Vb 1
\&  parallel \-\-xargs echo \*(AqBEGIN{\*(Aq{}\*(Aq}END\*(Aq ::: 1 2 3
.Ve
.PP
\&\fBmap\fR does not set exit value according to whether one of the jobs
failed:
.PP
.Vb 1
\&  parallel false ::: 1 || echo Job failed
\&
\&  map false 1 || echo Never run
.Ve
.PP
\&\fBmap\fR requires Perl v5.10.0 making it harder to use on old systems.
.PP
\&\fBmap\fR has no way of using % in the command (\s-1GNU\s0 Parallel has \-I to
specify another replacement string than {}).
.PP
By design \fBmap\fR is option incompatible with \fBxargs\fR, it does not
have remote job execution, a structured way of saving results,
multiple input sources, progress indicator, configurable record
delimiter (only field delimiter), logging of jobs run with possibility
to resume, keeping the output in the same order as input, \-\-pipe
processing, and dynamically timeouts.
.SS "\s-1DIFFERENCES BETWEEN\s0 ladon \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN ladon AND GNU Parallel"
\&\fBladon\fR can run multiple jobs on files in parallel.
.PP
\&\fBladon\fR only works on files and the only way to specify files is
using a quoted glob string (such as \e*.jpg). It is not possible to
list the files manually.
.PP
As replacement strings it uses \s-1FULLPATH DIRNAME BASENAME EXT RELDIR RELPATH\s0
.PP
These can be simulated using \s-1GNU \s0\fBparallel\fR by putting this in \fB~/.parallel/config\fR:
.PP
.Vb 6
\&    \-\-rpl \*(AqFULLPATH $_=::shell_quote($_);chomp($_=qx{readlink \-f $_});\*(Aq
\&    \-\-rpl \*(AqDIRNAME $_=::shell_quote(::dirname($_));chomp($_=qx{readlink \-f $_});\*(Aq
\&    \-\-rpl \*(AqBASENAME s:.*/::;s:\e.[^/.]+$::;\*(Aq
\&    \-\-rpl \*(AqEXT s:.*\e.::\*(Aq
\&    \-\-rpl \*(AqRELDIR $_=::shell_quote($_);chomp(($_,$c)=qx{readlink \-f $_;pwd});s:\eQ$c/\eE::;$_=::dirname($_);\*(Aq
\&    \-\-rpl \*(AqRELPATH $_=::shell_quote($_);chomp(($_,$c)=qx{readlink \-f $_;pwd});s:\eQ$c/\eE::;\*(Aq
.Ve
.PP
\&\fBladon\fR deals badly with filenames containing " and newline, and it fails for output larger than 200k:
.PP
.Vb 1
\&    ladon \*(Aq*\*(Aq \-\- seq 36000 | wc
.Ve
.PP
\fI\s-1EXAMPLES FROM\s0 ladon \s-1MANUAL\s0\fR
.IX Subsection "EXAMPLES FROM ladon MANUAL"
.PP
It is assumed that the '\-\-rpl's above are put in \fB~/.parallel/config\fR
and that it is run under a shell that supports '**' globbing (such as \fBzsh\fR):
.PP
\&\fB1\fR ladon \*(L"**/*.txt\*(R" \*(-- echo \s-1RELPATH\s0
.PP
\&\fB1\fR parallel echo \s-1RELPATH :::\s0 **/*.txt
.PP
\&\fB2\fR ladon \*(L"~/Documents/**/*.pdf\*(R" \*(-- shasum \s-1FULLPATH \s0>hashes.txt
.PP
\&\fB2\fR parallel shasum \s-1FULLPATH :::\s0 ~/Documents/**/*.pdf >hashes.txt
.PP
\&\fB3\fR ladon \-m thumbs/RELDIR \*(L"**/*.jpg\*(R" \*(-- convert \s-1FULLPATH\s0 \-thumbnail 100x100^ \-gravity center \-extent 100x100 thumbs/RELPATH
.PP
\&\fB3\fR parallel mkdir \-p thumbs/RELDIR\e; convert \s-1FULLPATH\s0 \-thumbnail 100x100^ \-gravity center \-extent 100x100 thumbs/RELPATH ::: **/*.jpg
.PP
\&\fB4\fR ladon \*(L"~/Music/*.wav\*(R" \*(-- lame \-V 2 \s-1FULLPATH DIRNAME/BASENAME\s0.mp3
.PP
\&\fB4\fR parallel lame \-V 2 \s-1FULLPATH DIRNAME/BASENAME\s0.mp3 ::: ~/Music/*.wav
.SS "\s-1DIFFERENCES BETWEEN\s0 ClusterSSH \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN ClusterSSH AND GNU Parallel"
ClusterSSH solves a different problem than \s-1GNU \s0\fBparallel\fR.
.PP
ClusterSSH opens a terminal window for each computer and using a
master window you can run the same command on all the computers. This
is typically used for administrating several computers that are almost
identical.
.PP
\&\s-1GNU \s0\fBparallel\fR runs the same (or different) commands with different
arguments in parallel possibly using remote computers to help
computing. If more than one computer is listed in \fB\-S\fR \s-1GNU \s0\fBparallel\fR may
only use one of these (e.g. if there are 8 jobs to be run and one
computer has 8 cores).
.PP
\&\s-1GNU \s0\fBparallel\fR can be used as a poor-man's version of ClusterSSH:
.PP
\&\fBparallel \-\-nonall \-S server\-a,server\-b do_stuff foo bar\fR
.SH "BUGS"
.IX Header "BUGS"
.SS "Quoting of newline"
.IX Subsection "Quoting of newline"
Because of the way newline is quoted this will not work:
.PP
.Vb 1
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa{}b\*(Aq"
.Ve
.PP
However, these will all work:
.PP
.Vb 3
\&  echo 1,2,3 | parallel \-vkd, echo a{}b
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa\*(Aq{}\*(Aqb\*(Aq"
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa\*(Aq"{}"\*(Aqb\*(Aq"
.Ve
.SS "Speed"
.IX Subsection "Speed"
\fIStartup\fR
.IX Subsection "Startup"
.PP
\&\s-1GNU \s0\fBparallel\fR is slow at starting up \- around 250 ms the first time
and 150 ms after that.
.PP
\fIJob startup\fR
.IX Subsection "Job startup"
.PP
Starting a job on the local machine takes around 10 ms. This can be a
big overhead if the job takes very few ms to run. Often you can group
small jobs together using \fB\-X\fR which will make the overhead less
significant. Or you can run multiple \s-1GNU \s0\fBparallel\fRs as described in
\&\fB\s-1EXAMPLE:\s0 Speeding up fast jobs\fR.
.PP
\fI\s-1SSH\s0\fR
.IX Subsection "SSH"
.PP
When using multiple computers \s-1GNU \s0\fBparallel\fR opens \fBssh\fR connections
to them to figure out how many connections can be used reliably
simultaneously (Namely \s-1SSHD\s0's MaxStartups). This test is done for each
host in serial, so if your \fB\-\-sshloginfile\fR contains many hosts it may
be slow.
.PP
If your jobs are short you may see that there are fewer jobs running
on the remove systems than expected. This is due to time spent logging
in and out. \fB\-M\fR may help here.
.PP
\fIDisk access\fR
.IX Subsection "Disk access"
.PP
A single disk can normally read data faster if it reads one file at a
time instead of reading a lot of files in parallel, as this will avoid
disk seeks. However, newer disk systems with multiple drives can read
faster if reading from multiple files in parallel.
.PP
If the jobs are of the form read-all-compute-all-write-all, so
everything is read before anything is written, it may be faster to
force only one disk access at the time:
.PP
.Vb 1
\&  sem \-\-id diskio cat file | compute | sem \-\-id diskio cat > file
.Ve
.PP
If the jobs are of the form read-compute-write, so writing starts
before all reading is done, it may be faster to force only one reader
and writer at the time:
.PP
.Vb 1
\&  sem \-\-id read cat file | compute | sem \-\-id write cat > file
.Ve
.PP
If the jobs are of the form read-compute-read-compute, it may be
faster to run more jobs in parallel than the system has CPUs, as some
of the jobs will be stuck waiting for disk access.
.SS "\-\-nice limits command length"
.IX Subsection "--nice limits command length"
The current implementation of \fB\-\-nice\fR is too pessimistic in the max
allowed command length. It only uses a little more than half of what
it could. This affects \fB\-X\fR and \fB\-m\fR. If this becomes a real problem for
you file a bug-report.
.SS "Aliases and functions do not work"
.IX Subsection "Aliases and functions do not work"
If you get:
.PP
.Vb 1
\&  Can\*(Aqt exec "command": No such file or directory
.Ve
.PP
or:
.PP
.Vb 1
\&  open3: exec of by command failed
.Ve
.PP
it may be because \fIcommand\fR is not known, but it could also be
because \fIcommand\fR is an alias or a function. If it is a function you
need to \fBexport \-f\fR the function first. An alias will, however, not
work (see why http://www.perlmonks.org/index.pl?node_id=484296), so
change your alias to a script.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Report bugs to <bug\-parallel@gnu.org> or
https://savannah.gnu.org/bugs/?func=additem&group=parallel
.PP
See a perfect bug report on
https://lists.gnu.org/archive/html/bug\-parallel/2015\-01/msg00000.html
.PP
Your bug report should always include:
.IP "\(bu" 2
The error message you get (if any).
.IP "\(bu" 2
The complete output of \fBparallel \-\-version\fR. If you are not running
the latest released version (see http://ftp.gnu.org/gnu/parallel/) you
should specify why you believe the problem is not fixed in that
version.
.IP "\(bu" 2
A complete example that others can run that shows the problem
including all files needed to run the example. This should preferably
be small and simple. A combination of \fByes\fR, \fBseq\fR, \fBcat\fR, \fBecho\fR,
and \fBsleep\fR can reproduce most errors. If your example requires large
files, see if you can make them by something like \fBseq 1000000\fR >
\&\fBfile\fR or \fByes | head \-n 10000000\fR > \fBfile\fR. If your example
requires remote execution, see if you can use \fBlocalhost\fR \- maybe
using another login.
.IP "\(bu" 2
The output of your example. If your problem is not easily reproduced
by others, the output might help them figure out the problem.
.IP "\(bu" 2
Whether you have watched the intro videos
(http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1), walked
through the tutorial (man parallel_tutorial), and read the \s-1EXAMPLE\s0
section in the man page (man parallel \- search for \s-1EXAMPLE:\s0).
.PP
If you suspect the error is dependent on your environment or
distribution, please see if you can reproduce the error on one of
these VirtualBox images:
http://sourceforge.net/projects/virtualboximage/files/
.PP
Specifying the name of your distribution is not enough as you may have
installed software that is not in the VirtualBox images.
.PP
If you cannot reproduce the error on any of the VirtualBox images
above, see if you can build a VirtualBox image on which you can
reproduce the error. If not you should assume the debugging will be
done through you. That will put more burden on you and it is extra
important you give any information that help. In general the problem
will be fixed faster and with less work for you if you can reproduce
the error on a VirtualBox.
.SH "AUTHOR"
.IX Header "AUTHOR"
When using \s-1GNU \s0\fBparallel\fR for a publication please cite:
.PP
O. Tange (2011): \s-1GNU\s0 Parallel \- The Command-Line Power Tool, ;login:
The \s-1USENIX\s0 Magazine, February 2011:42\-47.
.PP
This helps funding further development; and it won't cost you a cent.
If you pay 10000 \s-1EUR\s0 you should feel free to use \s-1GNU\s0 Parallel without citing.
.PP
Copyright (C) 2007\-10\-18 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2008,2009,2010 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2010,2011,2012,2013,2014,2015 Ole Tange,
http://ole.tange.dk and Free Software Foundation, Inc.
.PP
Parts of the manual concerning \fBxargs\fR compatibility is inspired by
the manual of \fBxargs\fR from \s-1GNU\s0 findutils 4.4.2.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2007,2008,2009,2010,2011,2012,2013,2014,2015 Free
Software Foundation, Inc.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 3 of the License, or
at your option any later version.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
.SS "Documentation license I"
.IX Subsection "Documentation license I"
Permission is granted to copy, distribute and/or modify this documentation
under the terms of the \s-1GNU\s0 Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the file fdl.txt.
.SS "Documentation license \s-1II\s0"
.IX Subsection "Documentation license II"
You are free:
.IP "\fBto Share\fR" 9
.IX Item "to Share"
to copy, distribute and transmit the work
.IP "\fBto Remix\fR" 9
.IX Item "to Remix"
to adapt the work
.PP
Under the following conditions:
.IP "\fBAttribution\fR" 9
.IX Item "Attribution"
You must attribute the work in the manner specified by the author or
licensor (but not in any way that suggests that they endorse you or
your use of the work).
.IP "\fBShare Alike\fR" 9
.IX Item "Share Alike"
If you alter, transform, or build upon this work, you may distribute
the resulting work only under the same, similar or a compatible
license.
.PP
With the understanding that:
.IP "\fBWaiver\fR" 9
.IX Item "Waiver"
Any of the above conditions can be waived if you get permission from
the copyright holder.
.IP "\fBPublic Domain\fR" 9
.IX Item "Public Domain"
Where the work or any of its elements is in the public domain under
applicable law, that status is in no way affected by the license.
.IP "\fBOther Rights\fR" 9
.IX Item "Other Rights"
In no way are any of the following rights affected by the license:
.RS 9
.IP "\(bu" 2
Your fair dealing or fair use rights, or other applicable
copyright exceptions and limitations;
.IP "\(bu" 2
The author's moral rights;
.IP "\(bu" 2
Rights other persons may have either in the work itself or in
how the work is used, such as publicity or privacy rights.
.RE
.RS 9
.RE
.IP "\fBNotice\fR" 9
.IX Item "Notice"
For any reuse or distribution, you must make clear to others the
license terms of this work.
.PP
A copy of the full license is included in the file as cc\-by\-sa.txt.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
\&\s-1GNU \s0\fBparallel\fR uses Perl, and the Perl modules Getopt::Long,
IPC::Open3, Symbol, IO::File, \s-1POSIX,\s0 and File::Temp. For remote usage
it also uses rsync with ssh.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBssh\fR(1), \fBrsync\fR(1), \fBfind\fR(1), \fBxargs\fR(1), \fBdirname\fR(1),
\&\fBmake\fR(1), \fBpexec\fR(1), \fBppss\fR(1), \fBxjobs\fR(1), \fBprll\fR(1),
\&\fBdxargs\fR(1), \fBmdm\fR(1)
